"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sign_exports = {};
__export(sign_exports, {
  acceptUserShare: () => acceptUserShare,
  decryptAndVerifyUserShare: () => decryptAndVerifyUserShare,
  presignWithDWalletID: () => presignWithDWalletID
});
module.exports = __toCommonJS(sign_exports);
var import_signature_mpc_wasm = require("@dwallet-network/signature-mpc-wasm");
var import_ed25519 = require("../keypairs/ed25519/index.js");
var import_dwallet_2pc_mpc_ecdsa_k1_module = require("./dwallet_2pc_mpc_ecdsa_k1_module.js");
var import_dwallet = require("./dwallet.js");
var import_encrypt_user_share = require("./encrypt_user_share.js");
const decryptAndVerifyUserShare = async (sourcePublicKey, expectedSourceSuiAddress, dkgOutput, encryptedUserShareObj, encryptionKeyObj) => {
  if (sourcePublicKey.toSuiAddress() !== expectedSourceSuiAddress) {
    throw new Error("The source public key does not match the expected Sui address");
  }
  let serializedPubKeys = (0, import_signature_mpc_wasm.serialized_pubkeys_from_decentralized_dkg_output)(
    new Uint8Array(dkgOutput)
  );
  if (!await sourcePublicKey.verify(
    serializedPubKeys,
    new Uint8Array(encryptedUserShareObj?.signedDWalletPubKeys)
  )) {
    throw new Error("the DWallet public keys have not been signed by the desired Sui address");
  }
  const decryptedKeyShare = (0, import_dwallet_2pc_mpc_ecdsa_k1_module.decrypt_user_share)(
    encryptionKeyObj.encryptionKey,
    encryptionKeyObj.decryptionKey,
    new Uint8Array(encryptedUserShareObj?.encryptedUserShareAndProof)
  );
  if (!(0, import_signature_mpc_wasm.verify_user_share)(decryptedKeyShare, new Uint8Array(dkgOutput))) {
    throw new Error("the decrypted key share doesn't match the dwallet's public key share");
  }
  return decryptedKeyShare;
};
const acceptUserShare = async (encryptedUserShare, expectedSourceSuiAddress, encryptionKeyObj, dwalletID, encryptionKeysHolderObjID, client, keypair) => {
  let dwallet = await (0, import_dwallet.getDwalletByObjID)(client, dwalletID);
  const decryptedKeyShare = await decryptAndVerifyUserShare(
    new import_ed25519.Ed25519PublicKey(encryptedUserShare?.senderPubKey),
    expectedSourceSuiAddress,
    dwallet?.decentralizedDKGOutput,
    encryptedUserShare,
    encryptionKeyObj
  );
  let dwalletToSend = {
    dwalletID,
    secretKeyShare: Array.from(decryptedKeyShare),
    decentralizedDKGOutput: dwallet.decentralizedDKGOutput
  };
  let serializedPubKeys = (0, import_signature_mpc_wasm.serialized_pubkeys_from_decentralized_dkg_output)(
    new Uint8Array(dwallet?.decentralizedDKGOutput)
  );
  const encryptedUserShareRef = await (0, import_encrypt_user_share.sendUserShareToSuiPubKey)(
    client,
    keypair,
    dwalletToSend,
    keypair.getPublicKey(),
    encryptionKeysHolderObjID,
    await keypair.sign(serializedPubKeys)
  );
  const activeEncryptionKeyObjID = await (0, import_dwallet.getActiveEncryptionKeyObjID)(
    client,
    keypair.toSuiAddress(),
    encryptionKeysHolderObjID
  );
  await (0, import_dwallet.saveEncryptedUserShare)(
    client,
    keypair,
    activeEncryptionKeyObjID,
    encryptedUserShareRef?.objectId
  );
  return true;
};
const presignWithDWalletID = async (client, keypair, dwalletID, message, hash, activeEncryptionKeysTableID) => {
  let encryptionKeyObj = await (0, import_encrypt_user_share.getOrCreateEncryptionKey)(
    keypair,
    client,
    activeEncryptionKeysTableID
  );
  let encryptedUserShareObjId = await (0, import_dwallet.getEncryptedUserShare)(client, keypair, dwalletID);
  let encryptedUserShareObj = await (0, import_dwallet.getEncryptedUserShareByObjectID)(
    client,
    encryptedUserShareObjId
  );
  let dwallet = await (0, import_dwallet.getDwalletByObjID)(client, dwalletID);
  const decryptedKeyShare = await decryptAndVerifyUserShare(
    keypair.getPublicKey(),
    keypair.toSuiAddress(),
    dwallet?.decentralizedDKGOutput,
    encryptedUserShareObj,
    encryptionKeyObj
  );
  return await (0, import_dwallet_2pc_mpc_ecdsa_k1_module.createPartialUserSignedMessages)(
    dwalletID,
    dwallet?.decentralizedDKGOutput,
    decryptedKeyShare,
    [message],
    hash,
    keypair,
    client
  );
};
//# sourceMappingURL=sign.js.map
