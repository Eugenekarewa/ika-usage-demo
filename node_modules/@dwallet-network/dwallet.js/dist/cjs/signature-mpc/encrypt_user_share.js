"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var encrypt_user_share_exports = {};
__export(encrypt_user_share_exports, {
  getEncryptedUserShareByObjID: () => getEncryptedUserShareByObjID,
  getOrCreateEncryptionKey: () => getOrCreateEncryptionKey,
  sendUserShareToSuiPubKey: () => sendUserShareToSuiPubKey
});
module.exports = __toCommonJS(encrypt_user_share_exports);
var import_dwallet_2pc_mpc_ecdsa_k1_module = require("./dwallet_2pc_mpc_ecdsa_k1_module.js");
var import_dwallet = require("./dwallet.js");
var import_utils = require("./utils.js");
const sendUserShareToSuiPubKey = async (client, keypair, dwallet, destinationPublicKey, activeEncryptionKeysTableID, signedDWalletPubKeys) => {
  const activeEncryptionKeyObjID = await (0, import_dwallet.getActiveEncryptionKeyObjID)(
    client,
    destinationPublicKey.toSuiAddress(),
    activeEncryptionKeysTableID
  );
  const recipientData = await (0, import_dwallet.getEncryptionKeyByObjectId)(client, activeEncryptionKeyObjID);
  let isValidEncryptionKey = await destinationPublicKey.verify(
    new Uint8Array(recipientData?.encryptionKey),
    new Uint8Array(recipientData?.signedEncryptionKey)
  );
  if (!isValidEncryptionKey) {
    throw new Error(
      "The destination public key has not been signed by the desired destination Sui address"
    );
  }
  const encryptedUserShareAndProof = (0, import_dwallet_2pc_mpc_ecdsa_k1_module.generate_proof)(
    new Uint8Array(dwallet.secretKeyShare),
    recipientData?.encryptionKey
  );
  return await (0, import_dwallet.transferEncryptedUserShare)(
    client,
    keypair,
    encryptedUserShareAndProof,
    activeEncryptionKeyObjID,
    dwallet,
    signedDWalletPubKeys
  );
};
const getEncryptedUserShareByObjID = async (client, objID) => {
  const response = await client.getObject({
    id: objID,
    options: { showContent: true }
  });
  const objectFields = response.data?.content?.dataType === "moveObject" ? response.data?.content?.fields : null;
  return objectFields ? {
    dwalletID: objectFields.dwallet_id,
    encryptedUserShareAndProof: objectFields.encrypted_secret_share_and_proof,
    encryptionKeyObjID: objectFields.encryption_key_id,
    signedDWalletPubKeys: objectFields.signed_dwallet_pubkeys,
    senderPubKey: objectFields.sender_pubkey
  } : null;
};
function isEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index) => value === arr2[index]);
}
const getOrCreateEncryptionKey = async (keypair, client, activeEncryptionKeysTableID) => {
  let [encryptionKey, decryptionKey] = (0, import_utils.generatePaillierKeyPairFromSuiKeyPair)(keypair);
  const activeEncryptionKeyObjID = await (0, import_dwallet.getActiveEncryptionKeyObjID)(
    client,
    keypair.toSuiAddress(),
    activeEncryptionKeysTableID
  );
  if (activeEncryptionKeyObjID) {
    let encryptionKeyObj = await (0, import_dwallet.getEncryptionKeyByObjectId)(client, activeEncryptionKeyObjID);
    if (isEqual(encryptionKeyObj?.encryptionKey, encryptionKey)) {
      return {
        encryptionKey,
        decryptionKey,
        objectID: activeEncryptionKeyObjID
      };
    }
    throw new Error(
      "Encryption key derived from Sui secret does not match the one in the active encryption keys table"
    );
  }
  const encryptionKeyRef = await (0, import_dwallet.storeEncryptionKey)(
    encryptionKey,
    import_dwallet.EncryptionKeyScheme.Paillier,
    keypair,
    client
  );
  await (0, import_dwallet.setActiveEncryptionKey)(
    client,
    keypair,
    encryptionKeyRef?.objectId,
    activeEncryptionKeysTableID
  );
  return {
    decryptionKey,
    encryptionKey,
    objectID: encryptionKeyRef.objectId
  };
};
//# sourceMappingURL=encrypt_user_share.js.map
