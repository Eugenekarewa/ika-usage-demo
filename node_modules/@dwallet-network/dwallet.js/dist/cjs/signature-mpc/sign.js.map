{
  "version": 3,
  "sources": ["../../../src/signature-mpc/sign.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\nimport {\n\tserialized_pubkeys_from_decentralized_dkg_output,\n\tverify_user_share,\n} from '@dwallet-network/signature-mpc-wasm';\n\nimport type { DWalletClient } from '../client/index.js';\nimport type { Keypair } from '../cryptography/index.js';\nimport type { Ed25519Keypair } from '../keypairs/ed25519/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/index.js';\nimport {\n\tcreatePartialUserSignedMessages,\n\tdecrypt_user_share,\n} from './dwallet_2pc_mpc_ecdsa_k1_module.js';\nimport {\n\tgetActiveEncryptionKeyObjID,\n\tgetDwalletByObjID,\n\tgetEncryptedUserShare,\n\tgetEncryptedUserShareByObjectID,\n\tsaveEncryptedUserShare,\n} from './dwallet.js';\nimport type { EncryptedUserShare, EncryptionKeyPair } from './encrypt_user_share.js';\nimport { getOrCreateEncryptionKey, sendUserShareToSuiPubKey } from './encrypt_user_share.js';\n\nexport const decryptAndVerifyUserShare = async (\n\tsourcePublicKey: Ed25519PublicKey,\n\texpectedSourceSuiAddress: string,\n\tdkgOutput: number[],\n\tencryptedUserShareObj: EncryptedUserShare,\n\tencryptionKeyObj: EncryptionKeyPair,\n): Promise<Uint8Array> => {\n\tif (sourcePublicKey.toSuiAddress() !== expectedSourceSuiAddress) {\n\t\tthrow new Error('The source public key does not match the expected Sui address');\n\t}\n\tlet serializedPubKeys = serialized_pubkeys_from_decentralized_dkg_output(\n\t\tnew Uint8Array(dkgOutput),\n\t);\n\tif (\n\t\t!(await sourcePublicKey.verify(\n\t\t\tserializedPubKeys,\n\t\t\tnew Uint8Array(encryptedUserShareObj?.signedDWalletPubKeys!),\n\t\t))\n\t) {\n\t\tthrow new Error('the DWallet public keys have not been signed by the desired Sui address');\n\t}\n\tconst decryptedKeyShare = decrypt_user_share(\n\t\tencryptionKeyObj.encryptionKey,\n\t\tencryptionKeyObj.decryptionKey,\n\t\tnew Uint8Array(encryptedUserShareObj?.encryptedUserShareAndProof!),\n\t);\n\tif (!verify_user_share(decryptedKeyShare, new Uint8Array(dkgOutput!))) {\n\t\tthrow new Error(\"the decrypted key share doesn't match the dwallet's public key share\");\n\t}\n\treturn decryptedKeyShare;\n};\n\nexport const acceptUserShare = async (\n\tencryptedUserShare: EncryptedUserShare,\n\texpectedSourceSuiAddress: string,\n\tencryptionKeyObj: EncryptionKeyPair,\n\tdwalletID: string,\n\tencryptionKeysHolderObjID: string,\n\tclient: DWalletClient,\n\tkeypair: Keypair,\n): Promise<boolean> => {\n\tlet dwallet = await getDwalletByObjID(client, dwalletID);\n\t// This function also verifies that the dkg output has been signed by the source public key.\n\tconst decryptedKeyShare = await decryptAndVerifyUserShare(\n\t\tnew Ed25519PublicKey(encryptedUserShare?.senderPubKey!),\n\t\texpectedSourceSuiAddress,\n\t\tdwallet?.decentralizedDKGOutput!,\n\t\tencryptedUserShare,\n\t\tencryptionKeyObj,\n\t);\n\tlet dwalletToSend = {\n\t\tdwalletID,\n\t\tsecretKeyShare: Array.from(decryptedKeyShare),\n\t\tdecentralizedDKGOutput: dwallet!.decentralizedDKGOutput,\n\t};\n\tlet serializedPubKeys = serialized_pubkeys_from_decentralized_dkg_output(\n\t\tnew Uint8Array(dwallet?.decentralizedDKGOutput!),\n\t);\n\t// Encrypt it to self, so that in the future we'd know that we already\n\t// verified everything and only need to verify our signature.\n\tconst encryptedUserShareRef = await sendUserShareToSuiPubKey(\n\t\tclient,\n\t\tkeypair,\n\t\tdwalletToSend,\n\t\tkeypair.getPublicKey(),\n\t\tencryptionKeysHolderObjID,\n\t\tawait keypair.sign(serializedPubKeys),\n\t);\n\tconst activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(\n\t\tclient,\n\t\tkeypair.toSuiAddress(),\n\t\tencryptionKeysHolderObjID,\n\t);\n\tawait saveEncryptedUserShare(\n\t\tclient,\n\t\tkeypair,\n\t\tactiveEncryptionKeyObjID,\n\t\tencryptedUserShareRef?.objectId!,\n\t);\n\treturn true;\n};\n\n/**\n * Pre-signs the given message with the given DWallet ID.\n *\n * @param client\n * @param keypair The Sui keypair that encrypted the given dwallet to itself in the past. This keypair is\n * either the one who created the dwallet with the {@link createDWallet} function, or the one who accepted\n * it with the {@link acceptUserShare} function.\n * @param dwalletID\n * @param message\n * @param hash\n * @param activeEncryptionKeysTableID\n */\nexport const presignWithDWalletID = async (\n\tclient: DWalletClient,\n\tkeypair: Ed25519Keypair,\n\tdwalletID: string,\n\tmessage: Uint8Array,\n\thash: 'KECCAK256' | 'SHA256',\n\tactiveEncryptionKeysTableID: string,\n): Promise<string | null> => {\n\tlet encryptionKeyObj = await getOrCreateEncryptionKey(\n\t\tkeypair,\n\t\tclient,\n\t\tactiveEncryptionKeysTableID,\n\t);\n\n\tlet encryptedUserShareObjId = await getEncryptedUserShare(client, keypair, dwalletID);\n\tlet encryptedUserShareObj = await getEncryptedUserShareByObjectID(\n\t\tclient,\n\t\tencryptedUserShareObjId!,\n\t);\n\tlet dwallet = await getDwalletByObjID(client, dwalletID);\n\tconst decryptedKeyShare = await decryptAndVerifyUserShare(\n\t\tkeypair.getPublicKey(),\n\t\tkeypair.toSuiAddress(),\n\t\tdwallet?.decentralizedDKGOutput!,\n\t\tencryptedUserShareObj!,\n\t\tencryptionKeyObj,\n\t);\n\treturn await createPartialUserSignedMessages(\n\t\tdwalletID,\n\t\tdwallet?.decentralizedDKGOutput!,\n\t\tdecryptedKeyShare,\n\t\t[message],\n\t\thash,\n\t\tkeypair,\n\t\tclient,\n\t);\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,gCAGO;AAKP,qBAAiC;AACjC,6CAGO;AACP,qBAMO;AAEP,gCAAmE;AAE5D,MAAM,4BAA4B,OACxC,iBACA,0BACA,WACA,uBACA,qBACyB;AACzB,MAAI,gBAAgB,aAAa,MAAM,0BAA0B;AAChE,UAAM,IAAI,MAAM,+DAA+D;AAAA,EAChF;AACA,MAAI,wBAAoB;AAAA,IACvB,IAAI,WAAW,SAAS;AAAA,EACzB;AACA,MACC,CAAE,MAAM,gBAAgB;AAAA,IACvB;AAAA,IACA,IAAI,WAAW,uBAAuB,oBAAqB;AAAA,EAC5D,GACC;AACD,UAAM,IAAI,MAAM,yEAAyE;AAAA,EAC1F;AACA,QAAM,wBAAoB;AAAA,IACzB,iBAAiB;AAAA,IACjB,iBAAiB;AAAA,IACjB,IAAI,WAAW,uBAAuB,0BAA2B;AAAA,EAClE;AACA,MAAI,KAAC,6CAAkB,mBAAmB,IAAI,WAAW,SAAU,CAAC,GAAG;AACtE,UAAM,IAAI,MAAM,sEAAsE;AAAA,EACvF;AACA,SAAO;AACR;AAEO,MAAM,kBAAkB,OAC9B,oBACA,0BACA,kBACA,WACA,2BACA,QACA,YACsB;AACtB,MAAI,UAAU,UAAM,kCAAkB,QAAQ,SAAS;AAEvD,QAAM,oBAAoB,MAAM;AAAA,IAC/B,IAAI,gCAAiB,oBAAoB,YAAa;AAAA,IACtD;AAAA,IACA,SAAS;AAAA,IACT;AAAA,IACA;AAAA,EACD;AACA,MAAI,gBAAgB;AAAA,IACnB;AAAA,IACA,gBAAgB,MAAM,KAAK,iBAAiB;AAAA,IAC5C,wBAAwB,QAAS;AAAA,EAClC;AACA,MAAI,wBAAoB;AAAA,IACvB,IAAI,WAAW,SAAS,sBAAuB;AAAA,EAChD;AAGA,QAAM,wBAAwB,UAAM;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ,aAAa;AAAA,IACrB;AAAA,IACA,MAAM,QAAQ,KAAK,iBAAiB;AAAA,EACrC;AACA,QAAM,2BAA2B,UAAM;AAAA,IACtC;AAAA,IACA,QAAQ,aAAa;AAAA,IACrB;AAAA,EACD;AACA,YAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,uBAAuB;AAAA,EACxB;AACA,SAAO;AACR;AAcO,MAAM,uBAAuB,OACnC,QACA,SACA,WACA,SACA,MACA,gCAC4B;AAC5B,MAAI,mBAAmB,UAAM;AAAA,IAC5B;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI,0BAA0B,UAAM,sCAAsB,QAAQ,SAAS,SAAS;AACpF,MAAI,wBAAwB,UAAM;AAAA,IACjC;AAAA,IACA;AAAA,EACD;AACA,MAAI,UAAU,UAAM,kCAAkB,QAAQ,SAAS;AACvD,QAAM,oBAAoB,MAAM;AAAA,IAC/B,QAAQ,aAAa;AAAA,IACrB,QAAQ,aAAa;AAAA,IACrB,SAAS;AAAA,IACT;AAAA,IACA;AAAA,EACD;AACA,SAAO,UAAM;AAAA,IACZ;AAAA,IACA,SAAS;AAAA,IACT;AAAA,IACA,CAAC,OAAO;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;",
  "names": []
}
