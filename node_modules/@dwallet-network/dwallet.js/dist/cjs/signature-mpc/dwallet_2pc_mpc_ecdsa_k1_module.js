"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dwallet_2pc_mpc_ecdsa_k1_module_exports = {};
__export(dwallet_2pc_mpc_ecdsa_k1_module_exports, {
  createDWallet: () => createDWallet,
  createPartialUserSignedMessages: () => createPartialUserSignedMessages,
  decrypt_user_share: () => import_signature_mpc_wasm2.decrypt_user_share,
  generate_keypair: () => import_signature_mpc_wasm2.generate_keypair,
  generate_keypair_from_seed: () => import_signature_mpc_wasm2.generate_keypair_from_seed,
  generate_proof: () => import_signature_mpc_wasm2.generate_proof
});
module.exports = __toCommonJS(dwallet_2pc_mpc_ecdsa_k1_module_exports);
var import_signature_mpc_wasm = require("@dwallet-network/signature-mpc-wasm");
var import_bcs = require("../bcs/index.js");
var import_builder = require("../builder/index.js");
var import_dwallet = require("./dwallet.js");
var import_utils = require("./utils.js");
var import_signature_mpc_wasm2 = require("@dwallet-network/signature-mpc-wasm");
const packageId = "0x3";
const dWallet2PCMPCECDSAK1ModuleName = "dwallet_2pc_mpc_ecdsa_k1";
async function createDWallet(keypair, client, encryptionKey, encryptionKeyObjId) {
  const resultDKG = (0, import_signature_mpc_wasm.initiate_dkg)();
  const commitmentToSecretKeyShare = resultDKG["commitment_to_secret_key_share"];
  const decommitmentRoundPartyState = resultDKG["decommitment_round_party_state"];
  const tx = new import_builder.TransactionBlock();
  const [cap] = tx.moveCall({
    target: `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::create_dkg_session`,
    arguments: [tx.pure(commitmentToSecretKeyShare)]
  });
  tx.transferObjects([cap], keypair.toSuiAddress());
  const result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  const sessionRef = result.effects?.created?.filter((o) => o.owner === "Immutable")[0].reference;
  const sessionOutput = await (0, import_utils.fetchObjectBySessionId)(
    sessionRef.objectId,
    `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::DKGSessionOutput`,
    keypair,
    client
  );
  const sessionOutputFields = sessionOutput?.dataType === "moveObject" ? sessionOutput.fields : null;
  if (sessionOutputFields) {
    const final = (0, import_signature_mpc_wasm.finalize_dkg)(
      decommitmentRoundPartyState,
      Uint8Array.from(sessionOutputFields.secret_key_share_encryption_and_proof),
      encryptionKey
    );
    let serializedPubKeys = (0, import_signature_mpc_wasm.serialized_pubkeys_from_centralized_dkg_output)(final["dkg_output"]);
    const txFinal = new import_builder.TransactionBlock();
    txFinal.moveCall({
      target: `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::create_dwallet`,
      arguments: [
        txFinal.object(sessionOutputFields.id.id),
        txFinal.pure(final["public_key_share_decommitment_and_proof"]),
        txFinal.pure(encryptionKeyObjId),
        txFinal.pure(final["encrypted_user_share_and_proof"]),
        txFinal.pure([...await keypair.sign(serializedPubKeys)]),
        txFinal.pure([...keypair.getPublicKey().toRawBytes()])
      ]
    });
    const signResult = await client.signAndExecuteTransactionBlock({
      signer: keypair,
      transactionBlock: txFinal,
      options: {
        showEffects: true
      }
    });
    let dwalletRef = signResult.effects?.created?.filter((o) => {
      return o.owner === "Immutable";
    })[0].reference;
    let encryptedShareRef = signResult.effects?.created?.filter((o) => o.owner === "Immutable")[1].reference;
    let dwalletObject = await client.getObject({
      id: dwalletRef.objectId,
      options: { showContent: true }
    });
    let dwalletObjectFields = dwalletObject.data?.content?.dataType === "moveObject" ? dwalletObject.data?.content?.fields : null;
    if (!dwalletObjectFields?.dwallet_cap_id) {
      let tempRef = dwalletRef;
      dwalletRef = encryptedShareRef;
      encryptedShareRef = tempRef;
      dwalletObject = await client.getObject({
        id: dwalletRef.objectId,
        options: { showContent: true }
      });
      dwalletObjectFields = dwalletObject.data?.content?.dataType === "moveObject" ? dwalletObject.data?.content?.fields : null;
    }
    await (0, import_dwallet.saveEncryptedUserShare)(client, keypair, encryptionKeyObjId, encryptedShareRef.objectId);
    return dwalletObjectFields ? {
      dwalletID: dwalletRef?.objectId,
      centralizedDKGOutput: final["dkg_output"],
      decentralizedDKGOutput: dwalletObjectFields.output,
      dwalletCapID: dwalletObjectFields.dwallet_cap_id,
      secretKeyShare: final["secret_key_share"],
      encryptedSecretShareObjID: encryptedShareRef.objectId
    } : null;
  }
  return null;
}
async function createPartialUserSignedMessages(dwalletID, decentralizedDKGOutput, secretKeyShare, messages, hash, keypair, client) {
  const resultPresign = (0, import_signature_mpc_wasm.initiate_presign)(
    Uint8Array.of(...decentralizedDKGOutput),
    secretKeyShare,
    messages.length
  );
  const nonceSharesCommitmentsAndBatchedProof = resultPresign["nonce_shares_commitments_and_batched_proof"];
  const signatureNonceSharesAndCommitmentRandomnesses = resultPresign["signature_nonce_shares_and_commitment_randomnesses"];
  const hashNum = (0, import_dwallet.hashToNumber)(hash);
  const tx = new import_builder.TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::create_presign_session`,
    arguments: [
      tx.object(dwalletID),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(messages)),
      tx.pure(nonceSharesCommitmentsAndBatchedProof),
      tx.pure.u8(hashNum)
    ]
  });
  const result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  const sessionRef = result.effects?.created?.filter((o) => o.owner === "Immutable")[0].reference;
  const sessionOutput = await (0, import_utils.fetchObjectBySessionId)(
    sessionRef.objectId,
    `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::PresignSessionOutput`,
    keypair,
    client
  );
  const sessionOutputFields = sessionOutput?.dataType === "moveObject" ? sessionOutput.fields : null;
  if (sessionOutputFields) {
    const presigns = (0, import_signature_mpc_wasm.finalize_presign)(
      Uint8Array.of(...decentralizedDKGOutput),
      secretKeyShare,
      signatureNonceSharesAndCommitmentRandomnesses,
      Uint8Array.from(sessionOutputFields.output)
    );
    const presignOutput = await (0, import_utils.fetchObjectBySessionId)(
      sessionRef.objectId,
      `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::Presign`,
      keypair,
      client
    );
    const presignOutputFields = presignOutput?.dataType === "moveObject" ? presignOutput.fields : null;
    if (presignOutputFields) {
      const bcsMessages = import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(messages).toBytes();
      const publicNonceEncryptedPartialSignatureAndProofs = (0, import_signature_mpc_wasm.initiate_sign)(
        Uint8Array.of(...decentralizedDKGOutput),
        secretKeyShare,
        presigns,
        bcsMessages,
        hashNum
      );
      const txFinal = new import_builder.TransactionBlock();
      const [signMessagesObject] = txFinal.moveCall({
        target: `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::create_partial_user_signed_messages`,
        arguments: [
          txFinal.object(dwalletID),
          txFinal.object(sessionRef.objectId),
          txFinal.object(sessionOutputFields.id.id),
          txFinal.object(presignOutputFields.id.id),
          txFinal.pure(publicNonceEncryptedPartialSignatureAndProofs)
        ]
      });
      txFinal.transferObjects([signMessagesObject], keypair.toSuiAddress());
      const resultFinal = await client.signAndExecuteTransactionBlock({
        signer: keypair,
        transactionBlock: txFinal,
        options: {
          showEffects: true,
          showObjectChanges: true
        }
      });
      return resultFinal.effects?.created?.at(0)?.reference.objectId;
    }
  }
  return null;
}
//# sourceMappingURL=dwallet_2pc_mpc_ecdsa_k1_module.js.map
