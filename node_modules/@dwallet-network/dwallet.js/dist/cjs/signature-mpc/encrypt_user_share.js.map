{
  "version": 3,
  "sources": ["../../../src/signature-mpc/encrypt_user_share.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport type { DWalletClient } from '../client/index.js';\nimport type { Keypair, PublicKey } from '../cryptography/index.js';\nimport type { Ed25519Keypair } from '../keypairs/ed25519/index.js';\nimport { generate_proof } from './dwallet_2pc_mpc_ecdsa_k1_module.js';\nimport {\n\tEncryptionKeyScheme,\n\tgetActiveEncryptionKeyObjID,\n\tgetEncryptionKeyByObjectId,\n\tsetActiveEncryptionKey,\n\tstoreEncryptionKey,\n\ttransferEncryptedUserShare,\n} from './dwallet.js';\nimport { generatePaillierKeyPairFromSuiKeyPair } from './utils.js';\n\nexport type DWalletToTransfer = {\n\tsecretKeyShare: number[];\n\tdecentralizedDKGOutput: number[];\n\tdwalletID: string;\n};\n\nexport type EncryptedUserShare = {\n\tdwalletID: string;\n\tencryptedUserShareAndProof: number[];\n\tencryptionKeyObjID: string;\n\tsignedDWalletPubKeys: number[];\n\tsenderPubKey: number[];\n};\n\n/**\n * Encrypts and sends the given secret user share to the given destination public key.\n *\n * @param client The DWallet client.\n * @param keypair The Sui keypair that was used to sign the signedDWalletPubKeys.\n * @param dwallet The dWallet that we want to send the secret user share of.\n * @param destinationPublicKey The ed2551 public key of the destination Sui address.\n * @param activeEncryptionKeysTableID The ID of the table that holds the active encryption keys.\n * @param signedDWalletPubKeys The signed DWallet public keys.\n */\nexport const sendUserShareToSuiPubKey = async (\n\tclient: DWalletClient,\n\tkeypair: Keypair,\n\tdwallet: DWalletToTransfer,\n\tdestinationPublicKey: PublicKey,\n\tactiveEncryptionKeysTableID: string,\n\tsignedDWalletPubKeys: Uint8Array,\n) => {\n\tconst activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(\n\t\tclient,\n\t\tdestinationPublicKey.toSuiAddress(),\n\t\tactiveEncryptionKeysTableID,\n\t);\n\n\tconst recipientData = await getEncryptionKeyByObjectId(client, activeEncryptionKeyObjID);\n\tlet isValidEncryptionKey = await destinationPublicKey.verify(\n\t\tnew Uint8Array(recipientData?.encryptionKey!),\n\t\tnew Uint8Array(recipientData?.signedEncryptionKey!),\n\t);\n\tif (!isValidEncryptionKey) {\n\t\tthrow new Error(\n\t\t\t'The destination public key has not been signed by the desired destination Sui address',\n\t\t);\n\t}\n\tconst encryptedUserShareAndProof = generate_proof(\n\t\tnew Uint8Array(dwallet.secretKeyShare),\n\t\trecipientData?.encryptionKey!,\n\t);\n\n\treturn await transferEncryptedUserShare(\n\t\tclient,\n\t\tkeypair,\n\t\tencryptedUserShareAndProof,\n\t\tactiveEncryptionKeyObjID,\n\t\tdwallet,\n\t\tsignedDWalletPubKeys,\n\t);\n};\n\nexport const getEncryptedUserShareByObjID = async (\n\tclient: DWalletClient,\n\tobjID: string,\n): Promise<EncryptedUserShare | null> => {\n\tconst response = await client.getObject({\n\t\tid: objID,\n\t\toptions: { showContent: true },\n\t});\n\n\tconst objectFields =\n\t\tresponse.data?.content?.dataType === 'moveObject'\n\t\t\t? (response.data?.content?.fields as unknown as {\n\t\t\t\t\tdwallet_id: string;\n\t\t\t\t\tencrypted_secret_share_and_proof: number[];\n\t\t\t\t\tencryption_key_id: string;\n\t\t\t\t\tsigned_dwallet_pubkeys: number[];\n\t\t\t\t\tsender_pubkey: number[];\n\t\t\t  })\n\t\t\t: null;\n\n\treturn objectFields\n\t\t? {\n\t\t\t\tdwalletID: objectFields.dwallet_id,\n\t\t\t\tencryptedUserShareAndProof: objectFields.encrypted_secret_share_and_proof,\n\t\t\t\tencryptionKeyObjID: objectFields.encryption_key_id,\n\t\t\t\tsignedDWalletPubKeys: objectFields.signed_dwallet_pubkeys,\n\t\t\t\tsenderPubKey: objectFields.sender_pubkey,\n\t\t  }\n\t\t: null;\n};\n\nexport type EncryptionKeyPair = {\n\tencryptionKey: Uint8Array;\n\tdecryptionKey: Uint8Array;\n\tobjectID: string;\n};\n\nfunction isEqual(arr1: Uint8Array, arr2: Uint8Array): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\n\treturn arr1.every((value, index) => value === arr2[index]);\n}\n\nexport const getOrCreateEncryptionKey = async (\n\tkeypair: Ed25519Keypair,\n\tclient: DWalletClient,\n\tactiveEncryptionKeysTableID: string,\n): Promise<EncryptionKeyPair> => {\n\tlet [encryptionKey, decryptionKey] = generatePaillierKeyPairFromSuiKeyPair(keypair);\n\tconst activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(\n\t\tclient,\n\t\tkeypair.toSuiAddress(),\n\t\tactiveEncryptionKeysTableID,\n\t);\n\tif (activeEncryptionKeyObjID) {\n\t\tlet encryptionKeyObj = await getEncryptionKeyByObjectId(client, activeEncryptionKeyObjID);\n\t\tif (isEqual(encryptionKeyObj?.encryptionKey!, encryptionKey)) {\n\t\t\treturn {\n\t\t\t\tencryptionKey,\n\t\t\t\tdecryptionKey,\n\t\t\t\tobjectID: activeEncryptionKeyObjID,\n\t\t\t};\n\t\t}\n\t\tthrow new Error(\n\t\t\t'Encryption key derived from Sui secret does not match the one in the active encryption keys table',\n\t\t);\n\t}\n\tconst encryptionKeyRef = await storeEncryptionKey(\n\t\tencryptionKey,\n\t\tEncryptionKeyScheme.Paillier,\n\t\tkeypair,\n\t\tclient,\n\t);\n\tawait setActiveEncryptionKey(\n\t\tclient,\n\t\tkeypair,\n\t\tencryptionKeyRef?.objectId!,\n\t\tactiveEncryptionKeysTableID,\n\t);\n\treturn {\n\t\tdecryptionKey,\n\t\tencryptionKey,\n\t\tobjectID: encryptionKeyRef.objectId,\n\t};\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,6CAA+B;AAC/B,qBAOO;AACP,mBAAsD;AA0B/C,MAAM,2BAA2B,OACvC,QACA,SACA,SACA,sBACA,6BACA,yBACI;AACJ,QAAM,2BAA2B,UAAM;AAAA,IACtC;AAAA,IACA,qBAAqB,aAAa;AAAA,IAClC;AAAA,EACD;AAEA,QAAM,gBAAgB,UAAM,2CAA2B,QAAQ,wBAAwB;AACvF,MAAI,uBAAuB,MAAM,qBAAqB;AAAA,IACrD,IAAI,WAAW,eAAe,aAAc;AAAA,IAC5C,IAAI,WAAW,eAAe,mBAAoB;AAAA,EACnD;AACA,MAAI,CAAC,sBAAsB;AAC1B,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AACA,QAAM,iCAA6B;AAAA,IAClC,IAAI,WAAW,QAAQ,cAAc;AAAA,IACrC,eAAe;AAAA,EAChB;AAEA,SAAO,UAAM;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAEO,MAAM,+BAA+B,OAC3C,QACA,UACwC;AACxC,QAAM,WAAW,MAAM,OAAO,UAAU;AAAA,IACvC,IAAI;AAAA,IACJ,SAAS,EAAE,aAAa,KAAK;AAAA,EAC9B,CAAC;AAED,QAAM,eACL,SAAS,MAAM,SAAS,aAAa,eACjC,SAAS,MAAM,SAAS,SAOzB;AAEJ,SAAO,eACJ;AAAA,IACA,WAAW,aAAa;AAAA,IACxB,4BAA4B,aAAa;AAAA,IACzC,oBAAoB,aAAa;AAAA,IACjC,sBAAsB,aAAa;AAAA,IACnC,cAAc,aAAa;AAAA,EAC3B,IACA;AACJ;AAQA,SAAS,QAAQ,MAAkB,MAA2B;AAC7D,MAAI,KAAK,WAAW,KAAK,QAAQ;AAChC,WAAO;AAAA,EACR;AAEA,SAAO,KAAK,MAAM,CAAC,OAAO,UAAU,UAAU,KAAK,KAAK,CAAC;AAC1D;AAEO,MAAM,2BAA2B,OACvC,SACA,QACA,gCACgC;AAChC,MAAI,CAAC,eAAe,aAAa,QAAI,oDAAsC,OAAO;AAClF,QAAM,2BAA2B,UAAM;AAAA,IACtC;AAAA,IACA,QAAQ,aAAa;AAAA,IACrB;AAAA,EACD;AACA,MAAI,0BAA0B;AAC7B,QAAI,mBAAmB,UAAM,2CAA2B,QAAQ,wBAAwB;AACxF,QAAI,QAAQ,kBAAkB,eAAgB,aAAa,GAAG;AAC7D,aAAO;AAAA,QACN;AAAA,QACA;AAAA,QACA,UAAU;AAAA,MACX;AAAA,IACD;AACA,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AACA,QAAM,mBAAmB,UAAM;AAAA,IAC9B;AAAA,IACA,mCAAoB;AAAA,IACpB;AAAA,IACA;AAAA,EACD;AACA,YAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,IAClB;AAAA,EACD;AACA,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA,UAAU,iBAAiB;AAAA,EAC5B;AACD;",
  "names": []
}
