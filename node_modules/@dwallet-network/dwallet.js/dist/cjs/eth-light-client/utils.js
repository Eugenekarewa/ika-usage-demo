"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  calculateMessageStorageSlot: () => calculateMessageStorageSlot,
  compareUint8Arrays: () => compareUint8Arrays,
  getEthereumStateById: () => getEthereumStateById,
  getLatestEthereumStateById: () => getLatestEthereumStateById,
  keysToSnakeCase: () => keysToSnakeCase,
  stringToArrayU8Bcs: () => stringToArrayU8Bcs
});
module.exports = __toCommonJS(utils_exports);
var import_ethers = require("ethers");
var import_bcs = require("../bcs/index.js");
function calculateKey(message, dwalletId) {
  const combined = import_ethers.ethers.concat([message, dwalletId]);
  return import_ethers.ethers.keccak256(combined);
}
function calculateMappingSlotForKey(key, mappingSlot) {
  const abiCoder = import_ethers.ethers.AbiCoder.defaultAbiCoder();
  const encoded = abiCoder.encode(["bytes32", "uint256"], [key, mappingSlot]);
  return import_ethers.ethers.keccak256(encoded);
}
function calculateMessageStorageSlot(message, dwalletId, dataSlot) {
  const messageBytes = import_ethers.ethers.toUtf8Bytes(message);
  const dwalletIdBytes = import_ethers.ethers.getBytes(dwalletId);
  const key = calculateKey(messageBytes, dwalletIdBytes);
  return calculateMappingSlotForKey(key, dataSlot);
}
const getLatestEthereumStateById = async (client, latestStateObjectId) => {
  let latestEthereumStateResponse = await client.getObject({
    id: latestStateObjectId,
    options: { showContent: true }
  });
  return latestEthereumStateResponse.data?.content?.dataType === "moveObject" ? latestEthereumStateResponse.data?.content?.fields : null;
};
const getEthereumStateById = async (client, currentEthereumStateId) => {
  let currentEthereumStateResponse = await client.getObject({
    id: currentEthereumStateId,
    options: { showContent: true }
  });
  return currentEthereumStateResponse.data?.content?.dataType === "moveObject" ? currentEthereumStateResponse.data?.content?.fields : null;
};
function stringToArrayU8Bcs(value) {
  let arrayU8 = Uint8Array.from(Array.from(value).map((c) => c.charCodeAt(0)));
  return import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(arrayU8, {
    size: arrayU8.length,
    maxSize: arrayU8.length * 2,
    allocateSize: arrayU8.length
  });
}
function compareUint8Arrays(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function keysToSnakeCase(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => keysToSnakeCase(item));
  } else if (obj !== null && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => {
        const newKey = camelToSnake(key);
        return [newKey, keysToSnakeCase(value)];
      })
    );
  } else {
    return obj;
  }
}
function camelToSnake(key) {
  return key.replace(/([A-Z])/g, (letter) => `_${letter.toLowerCase()}`);
}
//# sourceMappingURL=utils.js.map
