"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var eth_light_client_exports = {};
__export(eth_light_client_exports, {
  approveEthereumMessage: () => approveEthereumMessage,
  createEthereumDWallet: () => createEthereumDWallet,
  initEthereumState: () => initEthereumState
});
module.exports = __toCommonJS(eth_light_client_exports);
var import_eth_light_client_wasm = require("@dwallet-network/eth-light-client-wasm");
var import_ethers = require("ethers");
var import_bcs = require("../bcs/index.js");
var import_builder = require("../builder/index.js");
var import_rpc = require("./rpc.js");
var import_utils = require("./utils.js");
const packageId = "0x3";
const ethDWalletModuleName = "eth_dwallet";
const ethereumStateModuleName = "ethereum_state";
const createEthereumDWallet = async (dwalletCapId, latestEthereumStateId, keypair, client) => {
  const tx = new import_builder.TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${ethDWalletModuleName}::create_eth_dwallet_cap`,
    arguments: [tx.object(dwalletCapId), tx.object(latestEthereumStateId)]
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: { showEffects: true }
  });
  if (result.effects?.status.status !== "success") {
    throw new Error(
      "Failed to verify Ethereum state. Transaction effects: " + JSON.stringify(result.effects)
    );
  }
  return result.effects?.created?.at(0)?.reference.objectId;
};
const initEthereumState = async (network, rpc, contractAddress, contractApprovedTxSlot, keypair, client) => {
  let checkpoint = "";
  switch (network) {
    case "mainnet": {
      checkpoint = "0x886083d6ba589617fabc0e69127982299f60426ddbf863ade18b3dd30259c11d";
      break;
    }
    case "holesky": {
      checkpoint = "0x089ad025c4a629091ea8ff20ba34f3eaf5b2c690f1a9e2c29a64022d95ddf1a4";
      break;
    }
    default: {
      throw new Error("Invalid network");
    }
  }
  let bootstrapJson = await (0, import_rpc.getBootstrapData)(rpc, checkpoint);
  let bootstrap = bootstrapJson["data"];
  let state = (0, import_eth_light_client_wasm.get_initial_state_bcs)(checkpoint, rpc, network, bootstrap);
  let stateBytes = state["bytes"];
  let syncPeriod = (0, import_eth_light_client_wasm.get_current_period)(stateBytes);
  let updatesResponseJson = await (0, import_rpc.getUpdates)(rpc, syncPeriod);
  let updatesJson = JSON.stringify(updatesResponseJson.map((update) => update["data"]));
  let updatesBcs = (0, import_utils.stringToArrayU8Bcs)(updatesJson);
  let finalityUpdateResponse = await (0, import_rpc.getFinalityUpdate)(rpc);
  let finalityUpdateJson = JSON.stringify(finalityUpdateResponse["data"]);
  let finalityUpdateBcs = (0, import_utils.stringToArrayU8Bcs)(finalityUpdateJson);
  let optimisticUpdateResponse = await (0, import_rpc.getOptimisticUpdate)(rpc);
  let optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse["data"]);
  let optimisticUpdateBcs = (0, import_utils.stringToArrayU8Bcs)(optimisticUpdateJson);
  let stateBcs = import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(stateBytes, {
    size: stateBytes.length,
    maxSize: stateBytes.length * 2,
    allocateSize: stateBytes.length
  });
  let beaconBlockData = await (0, import_rpc.getBeaconBlockData)(rpc, finalityUpdateResponse);
  let beaconBlockTypeBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockType);
  let beaconBlockBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockJsonString);
  let beaconBlockBodyBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockBodyJsonString);
  let beaconBlockExecutionPayloadBcs = (0, import_utils.stringToArrayU8Bcs)(
    beaconBlockData.blockExecutionPayloadJsonString
  );
  let contractAddressArrayU8 = import_ethers.ethers.getBytes(contractAddress);
  let contractAddressBcs = import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(contractAddressArrayU8);
  const tx = new import_builder.TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${ethereumStateModuleName}::init_state`,
    arguments: [
      tx.pure(stateBcs),
      tx.pure(network),
      tx.pure(contractAddressBcs),
      tx.pure.u64(contractApprovedTxSlot),
      tx.pure(updatesBcs),
      tx.pure(finalityUpdateBcs),
      tx.pure(optimisticUpdateBcs),
      tx.pure(beaconBlockBcs),
      tx.pure(beaconBlockBodyBcs),
      tx.pure(beaconBlockExecutionPayloadBcs),
      tx.pure(beaconBlockTypeBcs)
    ],
    typeArguments: []
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: { showEffects: true }
  });
  return result.effects?.created?.filter(
    (o) => typeof o.owner === "object" && "Shared" in o.owner && o.owner.Shared.initial_shared_version !== void 0
  )[0].reference.objectId;
};
const approveEthereumMessage = async (ethDwalletCapId, message, dWalletID, latestStateObjectID, executionRpc, consensusRpc, keypair, client) => {
  let latestEthereumStateObj = await (0, import_utils.getLatestEthereumStateById)(client, latestStateObjectID);
  let currentEthereumStateID = latestEthereumStateObj?.eth_state_id;
  let currentEthereumStateObj = await (0, import_utils.getEthereumStateById)(client, currentEthereumStateID);
  let currentEthereumStateData = currentEthereumStateObj?.data;
  let currentEthereumStateArrayU8 = Uint8Array.from(currentEthereumStateData);
  let dataSlot = latestEthereumStateObj?.eth_smart_contract_slot;
  let contractAddress = latestEthereumStateObj?.eth_smart_contract_address;
  let contractAddressArrayU8 = Uint8Array.from(contractAddress);
  let contractAddressString = import_ethers.ethers.hexlify(contractAddressArrayU8);
  let proof = await (0, import_rpc.getProof)(
    message,
    dWalletID,
    dataSlot,
    contractAddressString,
    currentEthereumStateObj?.block_number,
    executionRpc
  );
  let state_root = currentEthereumStateObj?.state_root;
  let successful_proof = (0, import_eth_light_client_wasm.try_verify_proof)(
    proof,
    contractAddressString,
    message,
    import_ethers.ethers.getBytes(dWalletID),
    dataSlot,
    state_root
  );
  if (!successful_proof) {
    let syncPeriod = (0, import_eth_light_client_wasm.get_current_period)(currentEthereumStateArrayU8);
    let updatesResponseJson = await (0, import_rpc.getUpdates)(consensusRpc, syncPeriod);
    let updatesJson = JSON.stringify(updatesResponseJson.map((update) => update["data"]));
    let updatesBcs = (0, import_utils.stringToArrayU8Bcs)(updatesJson);
    let finalityUpdateResponseJson = await (0, import_rpc.getFinalityUpdate)(consensusRpc);
    let finalityUpdateJson = JSON.stringify(finalityUpdateResponseJson["data"]);
    let finalityUpdateBcs = (0, import_utils.stringToArrayU8Bcs)(finalityUpdateJson);
    let optimisticUpdateResponse = await (0, import_rpc.getOptimisticUpdate)(consensusRpc);
    let optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse["data"]);
    let optimisticUpdateBcs = (0, import_utils.stringToArrayU8Bcs)(optimisticUpdateJson);
    let beaconBlockData = await (0, import_rpc.getBeaconBlockData)(consensusRpc, finalityUpdateResponseJson);
    let beaconBlockTypeBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockType);
    let beaconBlockBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockJsonString);
    let beaconBlockBodyBcs = (0, import_utils.stringToArrayU8Bcs)(beaconBlockData.blockBodyJsonString);
    let beaconBlockExecutionPayloadBcs = (0, import_utils.stringToArrayU8Bcs)(
      beaconBlockData.blockExecutionPayloadJsonString
    );
    const tx = new import_builder.TransactionBlock();
    tx.moveCall({
      target: `${packageId}::${ethereumStateModuleName}::verify_new_state`,
      arguments: [
        tx.pure(updatesBcs),
        tx.pure(finalityUpdateBcs),
        tx.pure(optimisticUpdateBcs),
        tx.object(latestStateObjectID),
        tx.object(currentEthereumStateID),
        tx.pure(beaconBlockBcs),
        tx.pure(beaconBlockBodyBcs),
        tx.pure(beaconBlockExecutionPayloadBcs),
        tx.pure(beaconBlockTypeBcs)
      ]
    });
    let txResult2 = await client.signAndExecuteTransactionBlock({
      signer: keypair,
      transactionBlock: tx,
      options: { showEffects: true }
    });
    if (txResult2.effects?.status.status !== "success") {
      throw new Error(
        "Failed to verify Ethereum state. Transaction effects: " + JSON.stringify(txResult2.effects)
      );
    }
    latestEthereumStateObj = await (0, import_utils.getLatestEthereumStateById)(client, latestStateObjectID);
    currentEthereumStateID = latestEthereumStateObj?.eth_state_id;
    currentEthereumStateObj = await (0, import_utils.getEthereumStateById)(client, currentEthereumStateID);
    proof = await (0, import_rpc.getProof)(
      message,
      dWalletID,
      dataSlot,
      contractAddressString,
      currentEthereumStateObj?.block_number,
      executionRpc
    );
  }
  successful_proof = (0, import_eth_light_client_wasm.try_verify_proof)(
    proof,
    contractAddressString,
    message,
    import_ethers.ethers.getBytes(dWalletID),
    dataSlot,
    state_root
  );
  if (!successful_proof) {
    throw new Error("Failed to verify Ethereum state");
  }
  let proofBcs = (0, import_utils.stringToArrayU8Bcs)(JSON.stringify(proof));
  let messageBcs = (0, import_utils.stringToArrayU8Bcs)(message);
  const tx2 = new import_builder.TransactionBlock();
  tx2.moveCall({
    target: `${packageId}::${ethDWalletModuleName}::approve_message`,
    arguments: [
      tx2.object(ethDwalletCapId),
      tx2.pure(messageBcs),
      tx2.object(dWalletID),
      tx2.object(latestStateObjectID),
      tx2.object(currentEthereumStateID),
      tx2.pure(proofBcs)
    ]
  });
  let res = await client.devInspectTransactionBlock({
    sender: keypair.toSuiAddress(),
    transactionBlock: tx2
  });
  const messageApprovalBcs = new Uint8Array(
    res.results?.at(0)?.returnValues?.at(0)?.at(0)
  );
  let txResult = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx2,
    options: { showEffects: true }
  });
  if (txResult.effects?.status.status !== "success") {
    throw new Error("Failed to verify Ethereum state");
  }
  return messageApprovalBcs;
};
//# sourceMappingURL=eth-light-client.js.map
