{
  "version": 3,
  "sources": ["../../../src/eth-light-client/rpc.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport { ssz } from '@lodestar/types';\nimport { ethers } from 'ethers';\n\nimport { calculateMessageStorageSlot, compareUint8Arrays, keysToSnakeCase } from './utils.js';\n\n// Maximum number of light client updates per request\nconst MAX_REQUEST_LIGHT_CLIENT_UPDATES = 128;\n\ninterface VerifiedFinalityHeader {\n\tversion: 'phase0' | 'altair' | 'bellatrix' | 'capella' | 'deneb';\n\tdata: any;\n}\n\ntype BeaconBlockData = {\n\tblockJsonString: string;\n\tblockBodyJsonString: string;\n\tblockExecutionPayloadJsonString: string;\n\tblockType: string;\n\tlatestFinalizedBlockNumber: number;\n};\n\n/**\n * Retrieves a Merkle proof for a specific storage slot in an Ethereum smart contract.\n *\n * **Logic**\n * 1. **Calculate Storage Slot**: Calculates the storage slot for the given message and dWallet ID.\n * 2. **Fetch Proof**: Calls `getProofByStorageSlot` to retrieve the Merkle proof from the Ethereum execution client.\n *\n * **Arguments**\n * @param {string} message - The message associated with the storage slot.\n * @param {string} dwalletID - The dWallet ID.\n * @param {number} dataSlot - The data slot in the smart contract's storage.\n * @param {string} contractAddress - The Ethereum smart contract address.\n * @param {number} latestFinalizedBlockNumber - The latest finalized block number to query.\n * @param {string} executionRpc - The Ethereum execution RPC endpoint.\n *\n * **Returns**\n * The proof object retrieved from the Ethereum execution client.\n */\nexport async function getProof(\n\tmessage: string,\n\tdwalletID: string,\n\tdataSlot: number,\n\tcontractAddress: string,\n\tlatestFinalizedBlockNumber: number,\n\texecutionRpc: string,\n) {\n\tlet storageSlot = calculateMessageStorageSlot(message, dwalletID, dataSlot);\n\treturn await getProofByStorageSlot(\n\t\texecutionRpc,\n\t\tcontractAddress,\n\t\t[storageSlot],\n\t\tlatestFinalizedBlockNumber,\n\t);\n}\n\n/**\n * Retrieves beacon block data and processes it for use in the dWallet verification process.\n *\n * **Logic**\n * 1. **Get Verified Beacon Block**: Calls `getVerifiedBeaconBlock` to retrieve and verify the beacon block.\n * 2. **Convert Keys**: Converts keys in the block data to snake_case.\n * 3. **Serialize Block Data**: Serializes the block data, excluding certain fields for efficiency.\n * 4. **Extract Execution Payload**: Extracts the execution payload from the block body.\n * 5. **Prepare Data for Transaction**: Prepares the block data strings and block type for inclusion in a transaction.\n *\n * **Arguments**\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n * @param {VerifiedFinalityHeader} finalityUpdateJson - The finality update header used for verification.\n *\n * **Returns**\n * An object containing serialized block data strings, block type, and the latest finalized block number.\n * Note that the block data strings are serialized JSON objects, excluding certain fields for proper deserialization.\n *\n * **Errors**\n * Throws an error if the beacon block cannot be retrieved or verified.\n */\nexport async function getBeaconBlockData(\n\tconsensusRpc: string,\n\tfinalityUpdateJson: VerifiedFinalityHeader,\n) {\n\tlet block = await getVerifiedBeaconBlock(consensusRpc, finalityUpdateJson);\n\tblock = keysToSnakeCase(block);\n\n\tlet blockJsonString = JSON.stringify(block, (key, value) => {\n\t\tif (key === 'body') {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t});\n\n\tlet blockBody = block.body;\n\tlet blockBodyJsonString = JSON.stringify(blockBody, (key, value) => {\n\t\tif (key === 'execution_payload') {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn value;\n\t});\n\n\tlet blockExecutionPayload = blockBody.execution_payload;\n\tlet blockExecutionPayloadJsonString = JSON.stringify(blockExecutionPayload);\n\n\tlet result: BeaconBlockData = {\n\t\tblockJsonString: blockJsonString,\n\t\tblockBodyJsonString: blockBodyJsonString,\n\t\tblockExecutionPayloadJsonString: blockExecutionPayloadJsonString,\n\t\tblockType: finalityUpdateJson['version'],\n\t\tlatestFinalizedBlockNumber: blockExecutionPayload.block_number,\n\t};\n\n\treturn result;\n}\n\n/**\n * Retrieves light client updates from the Ethereum consensus client starting from a specific sync period.\n *\n * **Arguments**\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n * @param {number} syncPeriod - The starting sync period for fetching updates.\n *\n * **Returns**\n * The JSON response containing the light client updates.\n */\nexport async function getUpdates(consensusRpc: string, syncPeriod: number) {\n\tlet reqUrl = `${consensusRpc}/eth/v1/beacon/light_client/updates?start_period=${syncPeriod}&count=${MAX_REQUEST_LIGHT_CLIENT_UPDATES}`;\n\tconst response = await fetch(reqUrl);\n\tif (!response.ok) {\n\t\tthrow new Error(`could not fetch updates. HTTP Response status: ${response.status}`);\n\t}\n\n\treturn await response.json();\n}\n\n/**\n * Retrieves the latest finality update from the Ethereum consensus client.\n *\n * **Arguments**\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n *\n * **Returns**\n * The JSON response containing the finality update.\n */\nexport async function getFinalityUpdate(consensusRpc: string) {\n\tlet reqUrl = `${consensusRpc}/eth/v1/beacon/light_client/finality_update`;\n\tconst response = await fetch(reqUrl);\n\tif (!response.ok) {\n\t\tthrow new Error(`could not fetch finality update. HTTP Response status: ${response.status}`);\n\t}\n\n\treturn await response.json();\n}\n\n/**\n * Retrieves the latest optimistic update from the Ethereum consensus client.\n *\n * **Arguments**\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n *\n * **Returns**\n * The JSON response containing the optimistic update.\n */\nexport async function getOptimisticUpdate(consensusRpc: string) {\n\tlet reqUrl = `${consensusRpc}/eth/v1/beacon/light_client/finality_update`;\n\tconst response = await fetch(reqUrl);\n\tif (!response.ok) {\n\t\tthrow new Error(`could not fetch optimistic update. HTTP Response status: ${response.status}`);\n\t}\n\n\treturn await response.json();\n}\n\n/**\n * Retrieves bootstrap data for initializing the Ethereum light client.\n *\n * **Arguments**\n * @param {string} rpc - The Ethereum consensus RPC endpoint.\n * @param {string} checkpoint - The checkpoint root (block root) to fetch the bootstrap data for.\n *\n * **Returns**\n * The JSON response containing the bootstrap data.\n */\nexport async function getBootstrapData(rpc: string, checkpoint: string) {\n\tconst reqUrl = `${rpc}/eth/v1/beacon/light_client/bootstrap/${checkpoint}`;\n\tconst response = await fetch(reqUrl);\n\tif (!response.ok) {\n\t\tthrow new Error(`could not fetch bootstrap data. HTTP Response status: ${response.status}`);\n\t}\n\n\treturn await response.json();\n}\n\n/**\n * Retrieves and verifies a beacon block corresponding to a verified finality header.\n *\n * **Logic**\n * 1. **Determine Block Type**: Determines the block type from the `version` in the finality header.\n * 2. **Deserialize Finalized Header**: Deserializes the finalized header from the finality update.\n * 3. **Fetch Beacon Block**: Retrieves the beacon block corresponding to the slot in the finalized header.\n * 4. **Compute Hashes**: Computes the hash tree root of the beacon block and the finalized header.\n * 5. **Verify Match**: Compares the hashes to ensure the beacon block matches the finalized header.\n *\n * **Arguments**\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n * @param {VerifiedFinalityHeader} verifiedFinalityHeader - The verified finality header.\n *\n * **Returns**\n * The beacon block data if verification succeeds.\n */\nexport const getVerifiedBeaconBlock = async (\n\tconsensusRpc: string,\n\tverifiedFinalityHeader: VerifiedFinalityHeader,\n) => {\n\tlet blockType = verifiedFinalityHeader['version'];\n\tconst finalizedHeader = ssz.deneb.LightClientHeader.fromJson(\n\t\tverifiedFinalityHeader['data']['finalized_header'],\n\t);\n\tlet verifiedFinalizedHeaderHash = ssz.phase0.BeaconBlockHeader.hashTreeRoot(\n\t\tfinalizedHeader.beacon,\n\t);\n\n\tlet slot = finalizedHeader['beacon']['slot'];\n\tlet beaconBlock = await getBeaconBlock(consensusRpc, slot);\n\tlet beaconBlockData = beaconBlock['data']['message'];\n\n\tlet beaconBlockHash;\n\tlet block;\n\tswitch (blockType) {\n\t\tcase 'phase0':\n\t\t\tblock = ssz.phase0.BeaconBlock.fromJson(beaconBlockData);\n\t\t\tbeaconBlockHash = ssz.phase0.BeaconBlock.hashTreeRoot(block);\n\t\t\tbreak;\n\t\tcase 'altair':\n\t\t\tblock = ssz.altair.BeaconBlock.fromJson(beaconBlockData);\n\t\t\tbeaconBlockHash = ssz.altair.BeaconBlock.hashTreeRoot(block);\n\t\t\tbreak;\n\t\tcase 'bellatrix':\n\t\t\tblock = ssz.bellatrix.BeaconBlock.fromJson(beaconBlockData);\n\t\t\tbeaconBlockHash = ssz.bellatrix.BeaconBlock.hashTreeRoot(block);\n\t\t\tbreak;\n\t\tcase 'capella':\n\t\t\tblock = ssz.capella.BeaconBlock.fromJson(beaconBlockData);\n\t\t\tbeaconBlockHash = ssz.capella.BeaconBlock.hashTreeRoot(block);\n\t\t\tbreak;\n\t\tcase 'deneb':\n\t\t\tblock = ssz.deneb.BeaconBlock.fromJson(beaconBlockData);\n\t\t\tbeaconBlockHash = ssz.deneb.BeaconBlock.hashTreeRoot(block);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Invalid block type');\n\t}\n\n\tif (!compareUint8Arrays(beaconBlockHash, verifiedFinalizedHeaderHash)) {\n\t\tthrow new Error('Finality header does not match block');\n\t}\n\n\treturn beaconBlockData;\n};\n\nasync function getProofByStorageSlot(\n\texecutionRpc: string,\n\tcontractAddress: string,\n\tslots: string[],\n\tlatestFinalizedBlockNumber: number,\n) {\n\tlet address;\n\tlet provider = new ethers.JsonRpcProvider(executionRpc);\n\tif (!ethers.isAddress(contractAddress)) {\n\t\t// Resolve ENS name to address\n\t\taddress = await provider.resolveName(contractAddress);\n\t\tif (address === null) {\n\t\t\tthrow new Error('Invalid contract address');\n\t\t}\n\t} else {\n\t\taddress = contractAddress;\n\t}\n\n\tlet blockNumber =\n\t\tlatestFinalizedBlockNumber <= 0 ? 'latest' : ethers.toQuantity(latestFinalizedBlockNumber);\n\n\treturn await provider.send('eth_getProof', [address, slots, blockNumber]);\n}\n\nasync function getBeaconBlock(consensusRpc: string, slot: number) {\n\tlet reqUrl = `${consensusRpc}/eth/v2/beacon/blocks/${slot}`;\n\tconst response = await fetch(reqUrl);\n\tif (!response.ok) {\n\t\tthrow new Error(`could not fetch beacon block. HTTP Response status: ${response.status}`);\n\t}\n\n\treturn await response.json();\n}\n"],
  "mappings": "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",
  "names": []
}
