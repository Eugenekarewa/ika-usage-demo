import {
  serialized_pubkeys_from_decentralized_dkg_output,
  verify_signatures
} from "@dwallet-network/signature-mpc-wasm";
import { bcs } from "../bcs/index.js";
import { TransactionBlock } from "../builder/index.js";
import { fetchOwnedObjectByType } from "./utils.js";
const packageId = "0x3";
const dWalletModuleName = "dwallet";
const dWallet2PCMPCECDSAK1ModuleName = "dwallet_2pc_mpc_ecdsa_k1";
var EncryptionKeyScheme = /* @__PURE__ */ ((EncryptionKeyScheme2) => {
  EncryptionKeyScheme2[EncryptionKeyScheme2["Paillier"] = 0] = "Paillier";
  return EncryptionKeyScheme2;
})(EncryptionKeyScheme || {});
const getDwalletByObjID = async (client, dwalletObjID) => {
  const dwalletObject = await client.getObject({
    id: dwalletObjID,
    options: { showContent: true }
  });
  const dwalletObjectFields = dwalletObject.data?.content?.dataType === "moveObject" ? dwalletObject.data?.content?.fields : null;
  return dwalletObjectFields ? {
    dwalletID: dwalletObjID,
    decentralizedDKGOutput: dwalletObjectFields.output,
    dwalletCapID: dwalletObjectFields.dwallet_cap_id
  } : null;
};
function hashToNumber(hash) {
  if (hash === "KECCAK256") {
    return 0;
  } else {
    return 1;
  }
}
async function approveAndSign(dwalletCapId, signMessagesId, messages, dwalletID, hash, keypair, client) {
  const tx = new TransactionBlock();
  const [messageApprovals] = tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::approve_messages`,
    arguments: [
      tx.object(dwalletCapId),
      tx.pure(bcs.vector(bcs.vector(bcs.u8())).serialize(messages))
    ]
  });
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::sign`,
    typeArguments: [
      `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::SignData`,
      `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::CreatedSignDataEvent`
    ],
    arguments: [tx.object(signMessagesId), messageApprovals]
  });
  await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  let signatures = await waitForSignOutput(client);
  let encryptedUserShareObjId = await getEncryptedUserShare(client, keypair, dwalletID);
  let encryptedUserShareObj = await getEncryptedUserShareByObjectID(
    client,
    encryptedUserShareObjId
  );
  let dwallet = await getDwalletByObjID(client, dwalletID);
  let serializedPubkeys = serialized_pubkeys_from_decentralized_dkg_output(
    new Uint8Array(dwallet?.decentralizedDKGOutput)
  );
  if (!await keypair.getPublicKey().verify(serializedPubkeys, new Uint8Array(encryptedUserShareObj?.signedDWalletPubKeys))) {
    throw new Error("The DWallet public keys has not been signed by the desired Sui address");
  }
  if (!verify_signatures(
    bcs.vector(bcs.vector(bcs.u8())).serialize(messages).toBytes(),
    hashToNumber(hash),
    new Uint8Array(dwallet?.decentralizedDKGOutput),
    bcs.vector(bcs.vector(bcs.u8())).serialize(signatures).toBytes()
  )) {
    throw new Error("Returned signatures are not valid");
  }
  return signatures;
}
const waitForSignOutput = async (client) => {
  return new Promise((resolve) => {
    client.subscribeEvent({
      filter: {
        MoveEventType: `${packageId}::${dWalletModuleName}::SignOutputEvent`
      },
      onMessage: (event) => {
        let eventData = event?.parsedJson;
        resolve(eventData.signatures);
      }
    });
  });
};
const storeEncryptionKey = async (encryptionKey, encryptionKeyScheme, keypair, client) => {
  let signedEncryptionKey = await keypair.sign(new Uint8Array(encryptionKey));
  const tx = new TransactionBlock();
  let purePubKey = tx.pure(bcs.vector(bcs.u8()).serialize(encryptionKey));
  let pureSignedPubKey = tx.pure(bcs.vector(bcs.u8()).serialize(signedEncryptionKey));
  let pureSuiPubKey = tx.pure(bcs.vector(bcs.u8()).serialize(keypair.getPublicKey().toRawBytes()));
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::register_encryption_key`,
    arguments: [
      purePubKey,
      pureSignedPubKey,
      pureSuiPubKey,
      tx.pure(bcs.u8().serialize(encryptionKeyScheme))
    ]
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  return result.effects?.created?.filter((o) => o.owner === "Immutable")[0].reference;
};
const getEncryptionKeyByObjectId = async (client, encryptionKeyObjID) => {
  const response = await client.getObject({
    id: encryptionKeyObjID,
    options: { showContent: true }
  });
  const objectFields = response.data?.content?.dataType === "moveObject" ? response.data?.content?.fields : null;
  return objectFields ? {
    encryptionKey: objectFields?.encryption_key,
    signedEncryptionKey: objectFields?.encryption_key_signature,
    keyOwnerAddress: objectFields?.key_owner_address
  } : null;
};
const getEncryptedUserShareByObjectID = async (client, objID) => {
  const response = await client.getObject({
    id: objID,
    options: { showContent: true }
  });
  const objectFields = response.data?.content?.dataType === "moveObject" ? response.data?.content?.fields : null;
  return objectFields ? {
    dwalletID: objectFields?.dwallet_id,
    encryptedUserShareAndProof: objectFields?.encrypted_secret_share_and_proof,
    encryptionKeyObjID: objectFields?.encryption_key_id,
    signedDWalletPubKeys: objectFields.signed_dwallet_pubkeys,
    senderPubKey: objectFields.sender_pubkey
  } : null;
};
const getActiveEncryptionKeyObjID = async (client, keyOwnerAddress, encryptionKeysHolderID) => {
  const tx = new TransactionBlock();
  const encryptionKeysHolder = tx.object(encryptionKeysHolderID);
  console.log(keyOwnerAddress);
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::get_active_encryption_key`,
    arguments: [encryptionKeysHolder, tx.pure(keyOwnerAddress)]
  });
  let res = await client.devInspectTransactionBlock({
    sender: keyOwnerAddress,
    transactionBlock: tx
  });
  const array = new Uint8Array(res.results?.at(0)?.returnValues?.at(0)?.at(0));
  const hexString = Array.from(array).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return hexString;
};
const setActiveEncryptionKey = async (client, keypair, encryptionKeyObjID, encryptionKeysHolderID) => {
  const tx = new TransactionBlock();
  const EncKeyObj = tx.object(encryptionKeyObjID);
  const encryptionKeysHolder = tx.object(encryptionKeysHolderID);
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::set_active_encryption_key`,
    arguments: [encryptionKeysHolder, EncKeyObj]
  });
  return await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
};
const createActiveEncryptionKeysTable = async (client, keypair) => {
  const tx = new TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::create_active_encryption_keys`,
    arguments: []
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  return result.effects?.created?.filter(
    (o) => typeof o.owner === "object" && "Shared" in o.owner && o.owner.Shared.initial_shared_version !== void 0
  )[0].reference;
};
const transferEncryptedUserShare = async (client, keypair, encryptedUserShareAndProof, encryptionKeyObjID, dwallet, signedDWalletPubKeys) => {
  const tx = new TransactionBlock();
  const encryptionKey = tx.object(encryptionKeyObjID);
  const dwalletObj = tx.object(dwallet.dwalletID);
  let pureSuiPubKey = tx.pure(bcs.vector(bcs.u8()).serialize(keypair.getPublicKey().toRawBytes()));
  tx.moveCall({
    target: `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::encrypt_user_share`,
    typeArguments: [],
    arguments: [
      dwalletObj,
      encryptionKey,
      tx.pure(encryptedUserShareAndProof),
      tx.pure([...signedDWalletPubKeys]),
      pureSuiPubKey
    ]
  });
  const res = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  return res.effects?.created?.at(0)?.reference;
};
const createEncryptedUserSharesHolder = async (client, keypair) => {
  const tx = new TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::create_encrypted_user_shares`,
    arguments: []
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
  return result.effects?.created?.at(0)?.reference;
};
const getEncryptedUserSharesObjID = async (client, keypair) => {
  const table = await fetchOwnedObjectByType(
    `${packageId}::${dWalletModuleName}::EncryptedUserShares`,
    keypair,
    client
  );
  const tableFields = table?.dataType === "moveObject" ? table.fields : null;
  if (table === null) {
    const newTable = await createEncryptedUserSharesHolder(client, keypair);
    return newTable?.objectId;
  }
  return tableFields?.id.id;
};
const saveEncryptedUserShare = async (client, keypair, encryptionKeyID, encryptedUserShareId) => {
  const tx = new TransactionBlock();
  const encKey = tx.object(encryptionKeyID);
  const encryptedUserShare = tx.object(encryptedUserShareId);
  const encryptedUserSharesId = await getEncryptedUserSharesObjID(client, keypair);
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::save_encrypted_user_share`,
    arguments: [tx.object(encryptedUserSharesId), encryptedUserShare, encKey]
  });
  return await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: {
      showEffects: true
    }
  });
};
const getEncryptedUserShare = async (client, keypair, dwalletID) => {
  let encryptedUserSharesObjID = await getEncryptedUserSharesObjID(client, keypair);
  const tx = new TransactionBlock();
  const encryptedUserSharesObj = tx.object(encryptedUserSharesObjID);
  tx.moveCall({
    target: `${packageId}::${dWalletModuleName}::get_encrypted_user_share_by_dwallet_id`,
    arguments: [encryptedUserSharesObj, tx.pure(dwalletID)]
  });
  let res = await client.devInspectTransactionBlock({
    sender: keypair.toSuiAddress(),
    transactionBlock: tx
  });
  const array = new Uint8Array(res.results?.at(0)?.returnValues?.at(0)?.at(0));
  return Array.from(array).map((byte) => byte.toString(16).padStart(2, "0")).join("");
};
export {
  EncryptionKeyScheme,
  approveAndSign,
  createActiveEncryptionKeysTable,
  createEncryptedUserSharesHolder,
  getActiveEncryptionKeyObjID,
  getDwalletByObjID,
  getEncryptedUserShare,
  getEncryptedUserShareByObjectID,
  getEncryptedUserSharesObjID,
  getEncryptionKeyByObjectId,
  hashToNumber,
  saveEncryptedUserShare,
  setActiveEncryptionKey,
  storeEncryptionKey,
  transferEncryptedUserShare,
  waitForSignOutput
};
//# sourceMappingURL=dwallet.js.map
