import { generate_proof } from "./dwallet_2pc_mpc_ecdsa_k1_module.js";
import {
  EncryptionKeyScheme,
  getActiveEncryptionKeyObjID,
  getEncryptionKeyByObjectId,
  setActiveEncryptionKey,
  storeEncryptionKey,
  transferEncryptedUserShare
} from "./dwallet.js";
import { generatePaillierKeyPairFromSuiKeyPair } from "./utils.js";
const sendUserShareToSuiPubKey = async (client, keypair, dwallet, destinationPublicKey, activeEncryptionKeysTableID, signedDWalletPubKeys) => {
  const activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(
    client,
    destinationPublicKey.toSuiAddress(),
    activeEncryptionKeysTableID
  );
  const recipientData = await getEncryptionKeyByObjectId(client, activeEncryptionKeyObjID);
  let isValidEncryptionKey = await destinationPublicKey.verify(
    new Uint8Array(recipientData?.encryptionKey),
    new Uint8Array(recipientData?.signedEncryptionKey)
  );
  if (!isValidEncryptionKey) {
    throw new Error(
      "The destination public key has not been signed by the desired destination Sui address"
    );
  }
  const encryptedUserShareAndProof = generate_proof(
    new Uint8Array(dwallet.secretKeyShare),
    recipientData?.encryptionKey
  );
  return await transferEncryptedUserShare(
    client,
    keypair,
    encryptedUserShareAndProof,
    activeEncryptionKeyObjID,
    dwallet,
    signedDWalletPubKeys
  );
};
const getEncryptedUserShareByObjID = async (client, objID) => {
  const response = await client.getObject({
    id: objID,
    options: { showContent: true }
  });
  const objectFields = response.data?.content?.dataType === "moveObject" ? response.data?.content?.fields : null;
  return objectFields ? {
    dwalletID: objectFields.dwallet_id,
    encryptedUserShareAndProof: objectFields.encrypted_secret_share_and_proof,
    encryptionKeyObjID: objectFields.encryption_key_id,
    signedDWalletPubKeys: objectFields.signed_dwallet_pubkeys,
    senderPubKey: objectFields.sender_pubkey
  } : null;
};
function isEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index) => value === arr2[index]);
}
const getOrCreateEncryptionKey = async (keypair, client, activeEncryptionKeysTableID) => {
  let [encryptionKey, decryptionKey] = generatePaillierKeyPairFromSuiKeyPair(keypair);
  const activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(
    client,
    keypair.toSuiAddress(),
    activeEncryptionKeysTableID
  );
  if (activeEncryptionKeyObjID) {
    let encryptionKeyObj = await getEncryptionKeyByObjectId(client, activeEncryptionKeyObjID);
    if (isEqual(encryptionKeyObj?.encryptionKey, encryptionKey)) {
      return {
        encryptionKey,
        decryptionKey,
        objectID: activeEncryptionKeyObjID
      };
    }
    throw new Error(
      "Encryption key derived from Sui secret does not match the one in the active encryption keys table"
    );
  }
  const encryptionKeyRef = await storeEncryptionKey(
    encryptionKey,
    EncryptionKeyScheme.Paillier,
    keypair,
    client
  );
  await setActiveEncryptionKey(
    client,
    keypair,
    encryptionKeyRef?.objectId,
    activeEncryptionKeysTableID
  );
  return {
    decryptionKey,
    encryptionKey,
    objectID: encryptionKeyRef.objectId
  };
};
export {
  getEncryptedUserShareByObjID,
  getOrCreateEncryptionKey,
  sendUserShareToSuiPubKey
};
//# sourceMappingURL=encrypt_user_share.js.map
