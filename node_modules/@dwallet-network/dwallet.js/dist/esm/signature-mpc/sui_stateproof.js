import axios from "axios";
import { TransactionBlock } from "../builder/index.js";
const packageId = "0x3";
const stateProofModuleName = "sui_state_proof";
const dWalletModuleName = "dwallet";
const dWallet2PCMPCECDSAK1ModuleName = "dwallet_2pc_mpc_ecdsa_k1";
async function submitDWalletCreationProof(dwallet_client, sui_client, configObjectId, registryObjectId, dWalletCapId, txId, serviceUrl, keypair) {
  let tx = await sui_client.getTransactionBlock({
    digest: txId,
    options: {}
  });
  let seq = tx.checkpoint;
  if (!seq) {
    throw new Error("Checkpoint is undefined or null");
  }
  let { ckp_epoch_id, checkpoint_summary_bytes, checkpoint_contents_bytes, transaction_bytes } = await queryTxData(txId, serviceUrl);
  let txb = new TransactionBlock();
  let dWalletCap = await getOwnedObject(dwallet_client, dWalletCapId);
  let dWalletCapArg = txb.object(dWalletCap);
  let epoch_committee_id = await retrieveEpochCommitteeIdByEpoch(
    dwallet_client,
    ckp_epoch_id - 1,
    registryObjectId
  );
  let epochCommitteeObject = await getOwnedObject(dwallet_client, epoch_committee_id);
  let committeeArg = txb.object(epochCommitteeObject);
  let configObject = await getOwnedObject(dwallet_client, configObjectId);
  let configArg = txb.object(configObject);
  let checkpoint_arg = txb.pure(checkpoint_summary_bytes);
  let checkpoint_contents_arg = txb.pure(checkpoint_contents_bytes);
  let transaction_arg = txb.pure(transaction_bytes);
  txb.moveCall({
    target: `${packageId}::${stateProofModuleName}::create_dwallet_wrapper`,
    arguments: [
      configArg,
      dWalletCapArg,
      committeeArg,
      checkpoint_arg,
      checkpoint_contents_arg,
      transaction_arg
    ]
  });
  return dwallet_client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: txb,
    options: {
      showEffects: true
    }
  });
}
async function submitTxStateProof(dwallet_client, sui_client, dWalletId, configObjectId, registryObjectId, capWrapperRef, signMessagesId, txId, serviceUrl, keypair) {
  let tx = await sui_client.getTransactionBlock({
    digest: txId,
    options: {}
  });
  let seq = tx.checkpoint;
  if (!seq) {
    throw new Error("Checkpoint is undefined or null");
  }
  let { ckp_epoch_id, checkpoint_summary_bytes, checkpoint_contents_bytes, transaction_bytes } = await queryTxData(txId, serviceUrl);
  let txb = new TransactionBlock();
  let configObject = await getOwnedObject(dwallet_client, configObjectId);
  let configArg = txb.object(configObject);
  let capWrapperArg = txb.object({
    Object: {
      Shared: {
        objectId: capWrapperRef.objectId,
        initialSharedVersion: capWrapperRef.version,
        mutable: true
      }
    }
  });
  let epoch_committee_id = await retrieveEpochCommitteeIdByEpoch(
    dwallet_client,
    ckp_epoch_id - 1,
    registryObjectId
  );
  let epochCommitteeObject = await getOwnedObject(dwallet_client, epoch_committee_id);
  let committeeArg = txb.object(epochCommitteeObject);
  let checkpointArg = txb.pure(checkpoint_summary_bytes);
  let checkpointContentsArg = txb.pure(checkpoint_contents_bytes);
  let transactionArg = txb.pure(transaction_bytes);
  let [messageApprovalsVec] = txb.moveCall({
    target: `${packageId}::${stateProofModuleName}::transaction_state_proof`,
    arguments: [
      configArg,
      capWrapperArg,
      committeeArg,
      checkpointArg,
      checkpointContentsArg,
      transactionArg
    ]
  });
  let messageApprovals = txb.moveCall({
    target: `0x1::vector::pop_back`,
    typeArguments: ["vector<0x3::dwallet::MessageApproval>"],
    arguments: [messageApprovalsVec]
  });
  txb.moveCall({
    target: `0x1::vector::destroy_empty`,
    typeArguments: ["vector<0x3::dwallet::MessageApproval>"],
    arguments: [messageApprovalsVec]
  });
  txb.moveCall({
    target: `${packageId}::${dWalletModuleName}::sign`,
    typeArguments: [
      `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::SignData`,
      `${packageId}::${dWallet2PCMPCECDSAK1ModuleName}::CreatedSignDataEvent`
    ],
    arguments: [txb.object(signMessagesId), messageApprovals]
  });
  await dwallet_client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: txb,
    options: {
      showEffects: true
    }
  });
  return await retrieveSignResult(dwallet_client, dWalletId);
}
async function queryTxData(txId, url) {
  const params = { tx_id: txId };
  try {
    const response = await axios.get(url, { params });
    return response.data;
  } catch (error) {
    console.error("Error querying transaction data:", error);
    throw error;
  }
}
async function getOwnedObject(client, id) {
  const res = await client.getObject({ id });
  if (!res.data) {
    throw new Error("No object found");
  }
  return {
    Object: {
      ImmOrOwned: {
        digest: res.data.digest,
        objectId: id,
        version: res.data.version
      }
    }
  };
}
async function retrieveSignResult(client, dWalletId) {
  let reqEventFiltered = [];
  const queryInterval = 100;
  while (reqEventFiltered.length === 0) {
    const requestedEvents = await client.queryEvents({
      query: {
        MoveEventType: `${packageId}::${dWalletModuleName}::SignOutputEvent`
      },
      order: "descending"
    });
    reqEventFiltered = requestedEvents.data.filter((event) => {
      let eventData2 = event.parsedJson;
      return eventData2.dwallet_id === dWalletId;
    });
    if (reqEventFiltered.length === 0) {
      await new Promise((resolve) => setTimeout(resolve, queryInterval));
    }
  }
  let eventData = reqEventFiltered[0].parsedJson;
  return eventData.signatures;
}
async function retrieveEpochCommitteeIdByEpoch(client, targetEpoch, targetRegistryId) {
  const query = {
    MoveModule: {
      package: "0x0000000000000000000000000000000000000000000000000000000000000003",
      module: "sui_state_proof"
    }
  };
  let hasNext = true;
  let cursor = null;
  while (hasNext) {
    const res = await client.queryEvents({ query, cursor });
    if (!res.data || res.data.length === 0) {
      throw new Error("No events returned by the query");
    }
    const filtered = res.data.find((event) => {
      let json = event.parsedJson;
      if ("epoch" in json && "registry_id" in json) {
        const epoch = event.parsedJson?.epoch;
        const registryId = event.parsedJson?.registry_id;
        return epoch !== void 0 && Number(epoch) === targetEpoch && registryId === targetRegistryId;
      }
      return false;
    });
    if (filtered && filtered.parsedJson.epoch_committee_id) {
      return filtered.parsedJson.epoch_committee_id;
    }
    cursor = res.nextCursor ? { eventSeq: res.nextCursor.eventSeq, txDigest: res.nextCursor.txDigest } : null;
    hasNext = res.hasNextPage;
  }
  throw new Error("Epoch not found");
}
export {
  submitDWalletCreationProof,
  submitTxStateProof
};
//# sourceMappingURL=sui_stateproof.js.map
