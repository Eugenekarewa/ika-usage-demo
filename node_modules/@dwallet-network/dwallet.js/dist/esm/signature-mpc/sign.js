import {
  serialized_pubkeys_from_decentralized_dkg_output,
  verify_user_share
} from "@dwallet-network/signature-mpc-wasm";
import { Ed25519PublicKey } from "../keypairs/ed25519/index.js";
import {
  createPartialUserSignedMessages,
  decrypt_user_share
} from "./dwallet_2pc_mpc_ecdsa_k1_module.js";
import {
  getActiveEncryptionKeyObjID,
  getDwalletByObjID,
  getEncryptedUserShare,
  getEncryptedUserShareByObjectID,
  saveEncryptedUserShare
} from "./dwallet.js";
import { getOrCreateEncryptionKey, sendUserShareToSuiPubKey } from "./encrypt_user_share.js";
const decryptAndVerifyUserShare = async (sourcePublicKey, expectedSourceSuiAddress, dkgOutput, encryptedUserShareObj, encryptionKeyObj) => {
  if (sourcePublicKey.toSuiAddress() !== expectedSourceSuiAddress) {
    throw new Error("The source public key does not match the expected Sui address");
  }
  let serializedPubKeys = serialized_pubkeys_from_decentralized_dkg_output(
    new Uint8Array(dkgOutput)
  );
  if (!await sourcePublicKey.verify(
    serializedPubKeys,
    new Uint8Array(encryptedUserShareObj?.signedDWalletPubKeys)
  )) {
    throw new Error("the DWallet public keys have not been signed by the desired Sui address");
  }
  const decryptedKeyShare = decrypt_user_share(
    encryptionKeyObj.encryptionKey,
    encryptionKeyObj.decryptionKey,
    new Uint8Array(encryptedUserShareObj?.encryptedUserShareAndProof)
  );
  if (!verify_user_share(decryptedKeyShare, new Uint8Array(dkgOutput))) {
    throw new Error("the decrypted key share doesn't match the dwallet's public key share");
  }
  return decryptedKeyShare;
};
const acceptUserShare = async (encryptedUserShare, expectedSourceSuiAddress, encryptionKeyObj, dwalletID, encryptionKeysHolderObjID, client, keypair) => {
  let dwallet = await getDwalletByObjID(client, dwalletID);
  const decryptedKeyShare = await decryptAndVerifyUserShare(
    new Ed25519PublicKey(encryptedUserShare?.senderPubKey),
    expectedSourceSuiAddress,
    dwallet?.decentralizedDKGOutput,
    encryptedUserShare,
    encryptionKeyObj
  );
  let dwalletToSend = {
    dwalletID,
    secretKeyShare: Array.from(decryptedKeyShare),
    decentralizedDKGOutput: dwallet.decentralizedDKGOutput
  };
  let serializedPubKeys = serialized_pubkeys_from_decentralized_dkg_output(
    new Uint8Array(dwallet?.decentralizedDKGOutput)
  );
  const encryptedUserShareRef = await sendUserShareToSuiPubKey(
    client,
    keypair,
    dwalletToSend,
    keypair.getPublicKey(),
    encryptionKeysHolderObjID,
    await keypair.sign(serializedPubKeys)
  );
  const activeEncryptionKeyObjID = await getActiveEncryptionKeyObjID(
    client,
    keypair.toSuiAddress(),
    encryptionKeysHolderObjID
  );
  await saveEncryptedUserShare(
    client,
    keypair,
    activeEncryptionKeyObjID,
    encryptedUserShareRef?.objectId
  );
  return true;
};
const presignWithDWalletID = async (client, keypair, dwalletID, message, hash, activeEncryptionKeysTableID) => {
  let encryptionKeyObj = await getOrCreateEncryptionKey(
    keypair,
    client,
    activeEncryptionKeysTableID
  );
  let encryptedUserShareObjId = await getEncryptedUserShare(client, keypair, dwalletID);
  let encryptedUserShareObj = await getEncryptedUserShareByObjectID(
    client,
    encryptedUserShareObjId
  );
  let dwallet = await getDwalletByObjID(client, dwalletID);
  const decryptedKeyShare = await decryptAndVerifyUserShare(
    keypair.getPublicKey(),
    keypair.toSuiAddress(),
    dwallet?.decentralizedDKGOutput,
    encryptedUserShareObj,
    encryptionKeyObj
  );
  return await createPartialUserSignedMessages(
    dwalletID,
    dwallet?.decentralizedDKGOutput,
    decryptedKeyShare,
    [message],
    hash,
    keypair,
    client
  );
};
export {
  acceptUserShare,
  decryptAndVerifyUserShare,
  presignWithDWalletID
};
//# sourceMappingURL=sign.js.map
