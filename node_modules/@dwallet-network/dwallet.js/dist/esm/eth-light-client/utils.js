import { ethers } from "ethers";
import { bcs } from "../bcs/index.js";
function calculateKey(message, dwalletId) {
  const combined = ethers.concat([message, dwalletId]);
  return ethers.keccak256(combined);
}
function calculateMappingSlotForKey(key, mappingSlot) {
  const abiCoder = ethers.AbiCoder.defaultAbiCoder();
  const encoded = abiCoder.encode(["bytes32", "uint256"], [key, mappingSlot]);
  return ethers.keccak256(encoded);
}
function calculateMessageStorageSlot(message, dwalletId, dataSlot) {
  const messageBytes = ethers.toUtf8Bytes(message);
  const dwalletIdBytes = ethers.getBytes(dwalletId);
  const key = calculateKey(messageBytes, dwalletIdBytes);
  return calculateMappingSlotForKey(key, dataSlot);
}
const getLatestEthereumStateById = async (client, latestStateObjectId) => {
  let latestEthereumStateResponse = await client.getObject({
    id: latestStateObjectId,
    options: { showContent: true }
  });
  return latestEthereumStateResponse.data?.content?.dataType === "moveObject" ? latestEthereumStateResponse.data?.content?.fields : null;
};
const getEthereumStateById = async (client, currentEthereumStateId) => {
  let currentEthereumStateResponse = await client.getObject({
    id: currentEthereumStateId,
    options: { showContent: true }
  });
  return currentEthereumStateResponse.data?.content?.dataType === "moveObject" ? currentEthereumStateResponse.data?.content?.fields : null;
};
function stringToArrayU8Bcs(value) {
  let arrayU8 = Uint8Array.from(Array.from(value).map((c) => c.charCodeAt(0)));
  return bcs.vector(bcs.u8()).serialize(arrayU8, {
    size: arrayU8.length,
    maxSize: arrayU8.length * 2,
    allocateSize: arrayU8.length
  });
}
function compareUint8Arrays(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function keysToSnakeCase(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => keysToSnakeCase(item));
  } else if (obj !== null && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => {
        const newKey = camelToSnake(key);
        return [newKey, keysToSnakeCase(value)];
      })
    );
  } else {
    return obj;
  }
}
function camelToSnake(key) {
  return key.replace(/([A-Z])/g, (letter) => `_${letter.toLowerCase()}`);
}
export {
  calculateMessageStorageSlot,
  compareUint8Arrays,
  getEthereumStateById,
  getLatestEthereumStateById,
  keysToSnakeCase,
  stringToArrayU8Bcs
};
//# sourceMappingURL=utils.js.map
