import {
  get_current_period,
  get_initial_state_bcs,
  try_verify_proof
} from "@dwallet-network/eth-light-client-wasm";
import { ethers } from "ethers";
import { bcs } from "../bcs/index.js";
import { TransactionBlock } from "../builder/index.js";
import {
  getBeaconBlockData,
  getBootstrapData,
  getFinalityUpdate,
  getOptimisticUpdate,
  getProof,
  getUpdates
} from "./rpc.js";
import { getEthereumStateById, getLatestEthereumStateById, stringToArrayU8Bcs } from "./utils.js";
const packageId = "0x3";
const ethDWalletModuleName = "eth_dwallet";
const ethereumStateModuleName = "ethereum_state";
const createEthereumDWallet = async (dwalletCapId, latestEthereumStateId, keypair, client) => {
  const tx = new TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${ethDWalletModuleName}::create_eth_dwallet_cap`,
    arguments: [tx.object(dwalletCapId), tx.object(latestEthereumStateId)]
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: { showEffects: true }
  });
  if (result.effects?.status.status !== "success") {
    throw new Error(
      "Failed to verify Ethereum state. Transaction effects: " + JSON.stringify(result.effects)
    );
  }
  return result.effects?.created?.at(0)?.reference.objectId;
};
const initEthereumState = async (network, rpc, contractAddress, contractApprovedTxSlot, keypair, client) => {
  let checkpoint = "";
  switch (network) {
    case "mainnet": {
      checkpoint = "0x886083d6ba589617fabc0e69127982299f60426ddbf863ade18b3dd30259c11d";
      break;
    }
    case "holesky": {
      checkpoint = "0x089ad025c4a629091ea8ff20ba34f3eaf5b2c690f1a9e2c29a64022d95ddf1a4";
      break;
    }
    default: {
      throw new Error("Invalid network");
    }
  }
  let bootstrapJson = await getBootstrapData(rpc, checkpoint);
  let bootstrap = bootstrapJson["data"];
  let state = get_initial_state_bcs(checkpoint, rpc, network, bootstrap);
  let stateBytes = state["bytes"];
  let syncPeriod = get_current_period(stateBytes);
  let updatesResponseJson = await getUpdates(rpc, syncPeriod);
  let updatesJson = JSON.stringify(updatesResponseJson.map((update) => update["data"]));
  let updatesBcs = stringToArrayU8Bcs(updatesJson);
  let finalityUpdateResponse = await getFinalityUpdate(rpc);
  let finalityUpdateJson = JSON.stringify(finalityUpdateResponse["data"]);
  let finalityUpdateBcs = stringToArrayU8Bcs(finalityUpdateJson);
  let optimisticUpdateResponse = await getOptimisticUpdate(rpc);
  let optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse["data"]);
  let optimisticUpdateBcs = stringToArrayU8Bcs(optimisticUpdateJson);
  let stateBcs = bcs.vector(bcs.u8()).serialize(stateBytes, {
    size: stateBytes.length,
    maxSize: stateBytes.length * 2,
    allocateSize: stateBytes.length
  });
  let beaconBlockData = await getBeaconBlockData(rpc, finalityUpdateResponse);
  let beaconBlockTypeBcs = stringToArrayU8Bcs(beaconBlockData.blockType);
  let beaconBlockBcs = stringToArrayU8Bcs(beaconBlockData.blockJsonString);
  let beaconBlockBodyBcs = stringToArrayU8Bcs(beaconBlockData.blockBodyJsonString);
  let beaconBlockExecutionPayloadBcs = stringToArrayU8Bcs(
    beaconBlockData.blockExecutionPayloadJsonString
  );
  let contractAddressArrayU8 = ethers.getBytes(contractAddress);
  let contractAddressBcs = bcs.vector(bcs.u8()).serialize(contractAddressArrayU8);
  const tx = new TransactionBlock();
  tx.moveCall({
    target: `${packageId}::${ethereumStateModuleName}::init_state`,
    arguments: [
      tx.pure(stateBcs),
      tx.pure(network),
      tx.pure(contractAddressBcs),
      tx.pure.u64(contractApprovedTxSlot),
      tx.pure(updatesBcs),
      tx.pure(finalityUpdateBcs),
      tx.pure(optimisticUpdateBcs),
      tx.pure(beaconBlockBcs),
      tx.pure(beaconBlockBodyBcs),
      tx.pure(beaconBlockExecutionPayloadBcs),
      tx.pure(beaconBlockTypeBcs)
    ],
    typeArguments: []
  });
  let result = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx,
    options: { showEffects: true }
  });
  return result.effects?.created?.filter(
    (o) => typeof o.owner === "object" && "Shared" in o.owner && o.owner.Shared.initial_shared_version !== void 0
  )[0].reference.objectId;
};
const approveEthereumMessage = async (ethDwalletCapId, message, dWalletID, latestStateObjectID, executionRpc, consensusRpc, keypair, client) => {
  let latestEthereumStateObj = await getLatestEthereumStateById(client, latestStateObjectID);
  let currentEthereumStateID = latestEthereumStateObj?.eth_state_id;
  let currentEthereumStateObj = await getEthereumStateById(client, currentEthereumStateID);
  let currentEthereumStateData = currentEthereumStateObj?.data;
  let currentEthereumStateArrayU8 = Uint8Array.from(currentEthereumStateData);
  let dataSlot = latestEthereumStateObj?.eth_smart_contract_slot;
  let contractAddress = latestEthereumStateObj?.eth_smart_contract_address;
  let contractAddressArrayU8 = Uint8Array.from(contractAddress);
  let contractAddressString = ethers.hexlify(contractAddressArrayU8);
  let proof = await getProof(
    message,
    dWalletID,
    dataSlot,
    contractAddressString,
    currentEthereumStateObj?.block_number,
    executionRpc
  );
  let state_root = currentEthereumStateObj?.state_root;
  let successful_proof = try_verify_proof(
    proof,
    contractAddressString,
    message,
    ethers.getBytes(dWalletID),
    dataSlot,
    state_root
  );
  if (!successful_proof) {
    let syncPeriod = get_current_period(currentEthereumStateArrayU8);
    let updatesResponseJson = await getUpdates(consensusRpc, syncPeriod);
    let updatesJson = JSON.stringify(updatesResponseJson.map((update) => update["data"]));
    let updatesBcs = stringToArrayU8Bcs(updatesJson);
    let finalityUpdateResponseJson = await getFinalityUpdate(consensusRpc);
    let finalityUpdateJson = JSON.stringify(finalityUpdateResponseJson["data"]);
    let finalityUpdateBcs = stringToArrayU8Bcs(finalityUpdateJson);
    let optimisticUpdateResponse = await getOptimisticUpdate(consensusRpc);
    let optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse["data"]);
    let optimisticUpdateBcs = stringToArrayU8Bcs(optimisticUpdateJson);
    let beaconBlockData = await getBeaconBlockData(consensusRpc, finalityUpdateResponseJson);
    let beaconBlockTypeBcs = stringToArrayU8Bcs(beaconBlockData.blockType);
    let beaconBlockBcs = stringToArrayU8Bcs(beaconBlockData.blockJsonString);
    let beaconBlockBodyBcs = stringToArrayU8Bcs(beaconBlockData.blockBodyJsonString);
    let beaconBlockExecutionPayloadBcs = stringToArrayU8Bcs(
      beaconBlockData.blockExecutionPayloadJsonString
    );
    const tx = new TransactionBlock();
    tx.moveCall({
      target: `${packageId}::${ethereumStateModuleName}::verify_new_state`,
      arguments: [
        tx.pure(updatesBcs),
        tx.pure(finalityUpdateBcs),
        tx.pure(optimisticUpdateBcs),
        tx.object(latestStateObjectID),
        tx.object(currentEthereumStateID),
        tx.pure(beaconBlockBcs),
        tx.pure(beaconBlockBodyBcs),
        tx.pure(beaconBlockExecutionPayloadBcs),
        tx.pure(beaconBlockTypeBcs)
      ]
    });
    let txResult2 = await client.signAndExecuteTransactionBlock({
      signer: keypair,
      transactionBlock: tx,
      options: { showEffects: true }
    });
    if (txResult2.effects?.status.status !== "success") {
      throw new Error(
        "Failed to verify Ethereum state. Transaction effects: " + JSON.stringify(txResult2.effects)
      );
    }
    latestEthereumStateObj = await getLatestEthereumStateById(client, latestStateObjectID);
    currentEthereumStateID = latestEthereumStateObj?.eth_state_id;
    currentEthereumStateObj = await getEthereumStateById(client, currentEthereumStateID);
    proof = await getProof(
      message,
      dWalletID,
      dataSlot,
      contractAddressString,
      currentEthereumStateObj?.block_number,
      executionRpc
    );
  }
  successful_proof = try_verify_proof(
    proof,
    contractAddressString,
    message,
    ethers.getBytes(dWalletID),
    dataSlot,
    state_root
  );
  if (!successful_proof) {
    throw new Error("Failed to verify Ethereum state");
  }
  let proofBcs = stringToArrayU8Bcs(JSON.stringify(proof));
  let messageBcs = stringToArrayU8Bcs(message);
  const tx2 = new TransactionBlock();
  tx2.moveCall({
    target: `${packageId}::${ethDWalletModuleName}::approve_message`,
    arguments: [
      tx2.object(ethDwalletCapId),
      tx2.pure(messageBcs),
      tx2.object(dWalletID),
      tx2.object(latestStateObjectID),
      tx2.object(currentEthereumStateID),
      tx2.pure(proofBcs)
    ]
  });
  let res = await client.devInspectTransactionBlock({
    sender: keypair.toSuiAddress(),
    transactionBlock: tx2
  });
  const messageApprovalBcs = new Uint8Array(
    res.results?.at(0)?.returnValues?.at(0)?.at(0)
  );
  let txResult = await client.signAndExecuteTransactionBlock({
    signer: keypair,
    transactionBlock: tx2,
    options: { showEffects: true }
  });
  if (txResult.effects?.status.status !== "success") {
    throw new Error("Failed to verify Ethereum state");
  }
  return messageApprovalBcs;
};
export {
  approveEthereumMessage,
  createEthereumDWallet,
  initEthereumState
};
//# sourceMappingURL=eth-light-client.js.map
