{
  "version": 3,
  "sources": ["../../../src/eth-light-client/utils.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\nimport { ethers } from 'ethers';\n\nimport { bcs } from '../bcs/index.js';\nimport type { DWalletClient } from '../client/index.js';\n\n/**\n * Calculates the key for a given message and dWallet ID.\n * In the smart contract, the key is calculated by hashing the message and the dWallet ID together.\n * The result is a 32-byte hash represented as a hexadecimal string.\n * @param {Uint8Array} message - A Uint8Array representing the message to be stored.\n * @param {Uint8Array} dwalletId - A Uint8Array representing the dWallet ID.\n * @returns A string representing the calculated key (hexadecimal format).\n */\nfunction calculateKey(message: Uint8Array, dwalletId: Uint8Array): string {\n\tconst combined = ethers.concat([message, dwalletId]);\n\treturn ethers.keccak256(combined);\n}\n\n/**\n * Calculates the mapping slot for a given key and storage slot in the contract's storage layout.\n * The key and slot are ABI-encoded and hashed together to produce a storage slot.\n * @param {string} key - A string (hexadecimal format) representing the key for which the mapping slot is to be calculated.\n * @param {number} mappingSlot - A BigInt value representing the mapping slot in the contract storage layout.\n * @returns A string representing the calculated storage slot (hexadecimal format).\n */\nfunction calculateMappingSlotForKey(key: string, mappingSlot: number): string {\n\tconst abiCoder = ethers.AbiCoder.defaultAbiCoder();\n\tconst encoded = abiCoder.encode(['bytes32', 'uint256'], [key, mappingSlot]);\n\treturn ethers.keccak256(encoded);\n}\n\n/**\n * Calculates the storage slot for a given message, dWallet ID, and data slot.\n * The function first calculates a key by hashing the message and the dWallet ID together.\n * Then, it calculates the mapping slot for the calculated key and the provided data slot.\n * The calculated mapping slot can be used to locate the (key, value) pair in the contract's storage.\n * @param {string} message - A string representing the message to be stored.\n * @param {string} dwalletId - A Uint8Array representing the dWallet ID.\n * @param {number} dataSlot - A BigInt value representing the data slot.\n * @returns A string representing the calculated storage slot (hexadecimal format).\n */\nexport function calculateMessageStorageSlot(\n\tmessage: string,\n\tdwalletId: string,\n\tdataSlot: number,\n): string {\n\tconst messageBytes = ethers.toUtf8Bytes(message);\n\tconst dwalletIdBytes = ethers.getBytes(dwalletId);\n\tconst key = calculateKey(messageBytes, dwalletIdBytes);\n\treturn calculateMappingSlotForKey(key, dataSlot);\n}\n\n/**\n * Retrieves the latest Ethereum state object by its ID.\n *\n * @param {DWalletClient} client - The dWallet client instance.\n * @param {string} latestStateObjectId - The ObjectID of the latest Ethereum state.\n * @returns An object containing the latest Ethereum state fields, or null if not found.\n */\nexport const getLatestEthereumStateById = async (\n\tclient: DWalletClient,\n\tlatestStateObjectId: string,\n) => {\n\tlet latestEthereumStateResponse = await client.getObject({\n\t\tid: latestStateObjectId,\n\t\toptions: { showContent: true },\n\t});\n\n\treturn latestEthereumStateResponse.data?.content?.dataType === 'moveObject'\n\t\t? (latestEthereumStateResponse.data?.content?.fields as unknown as {\n\t\t\t\tid: string;\n\t\t\t\teth_state_id: string;\n\t\t\t\ttime_slot: bigint;\n\t\t\t\teth_smart_contract_address: number[];\n\t\t\t\teth_smart_contract_slot: number;\n\t\t\t\tnetwork: string;\n\t\t  })\n\t\t: null;\n};\n\n/**\n * Retrieves the Ethereum state object by its ID.\n *\n * @param {DWalletClient} client - The dWallet client instance.\n * @param {string | undefined} currentEthereumStateId - The ObjectID of the current Ethereum state.\n * @returns An object containing the Ethereum state fields, or null if not found.\n */\nexport const getEthereumStateById = async (\n\tclient: DWalletClient,\n\tcurrentEthereumStateId: string | undefined,\n) => {\n\tlet currentEthereumStateResponse = await client.getObject({\n\t\tid: currentEthereumStateId as string,\n\t\toptions: { showContent: true },\n\t});\n\n\treturn currentEthereumStateResponse.data?.content?.dataType === 'moveObject'\n\t\t? (currentEthereumStateResponse.data?.content?.fields as unknown as {\n\t\t\t\tid: string;\n\t\t\t\tdata: number[];\n\t\t\t\ttime_slot: number;\n\t\t\t\tlatest_ethereum_state_id: string;\n\t\t\t\tstate_root: number[];\n\t\t\t\tblock_number: number;\n\t\t  })\n\t\t: null;\n};\n\n/**\n * Converts a string to a Uint8Array and serializes it using BCS (Binary Canonical Serialization).\n *\n * @param {string} value - The string to convert and serialize.\n * @returns The serialized Uint8Array.\n */\nexport function stringToArrayU8Bcs(value: string) {\n\tlet arrayU8 = Uint8Array.from(Array.from(value).map((c) => c.charCodeAt(0)));\n\treturn bcs.vector(bcs.u8()).serialize(arrayU8, {\n\t\tsize: arrayU8.length,\n\t\tmaxSize: arrayU8.length * 2,\n\t\tallocateSize: arrayU8.length,\n\t});\n}\n\n/**\n * Compares two Uint8Arrays for equality.\n *\n * @param {Uint8Array} a - The first Uint8Array to compare.\n * @param {Uint8Array} b - The second Uint8Array to compare.\n * @returns {boolean} True if both arrays are equal, false otherwise.\n */\nexport function compareUint8Arrays(a: Uint8Array, b: Uint8Array): boolean {\n\tif (a === b) return true;\n\tif (a.length !== b.length) return false;\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\treturn true;\n}\n\n/**\n * Converts all keys in an object to snake_case recursively.\n *\n * @param {any} obj - The object to convert.\n * @returns {any} A new object with all keys converted to snake_case.\n */\nexport function keysToSnakeCase(obj: any): any {\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map((item) => keysToSnakeCase(item));\n\t} else if (obj !== null && typeof obj === 'object') {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(obj).map(([key, value]) => {\n\t\t\t\tconst newKey = camelToSnake(key);\n\t\t\t\treturn [newKey, keysToSnakeCase(value)];\n\t\t\t}),\n\t\t);\n\t} else {\n\t\treturn obj;\n\t}\n}\n\n/**\n * Converts a camelCase string to snake_case.\n *\n * @param {string} key - The camelCase string to convert.\n * @returns {string} The converted snake_case string.\n */\nfunction camelToSnake(key: string): string {\n\treturn key.replace(/([A-Z])/g, (letter) => `_${letter.toLowerCase()}`);\n}\n"],
  "mappings": "AAEA,SAAS,cAAc;AAEvB,SAAS,WAAW;AAWpB,SAAS,aAAa,SAAqB,WAA+B;AACzE,QAAM,WAAW,OAAO,OAAO,CAAC,SAAS,SAAS,CAAC;AACnD,SAAO,OAAO,UAAU,QAAQ;AACjC;AASA,SAAS,2BAA2B,KAAa,aAA6B;AAC7E,QAAM,WAAW,OAAO,SAAS,gBAAgB;AACjD,QAAM,UAAU,SAAS,OAAO,CAAC,WAAW,SAAS,GAAG,CAAC,KAAK,WAAW,CAAC;AAC1E,SAAO,OAAO,UAAU,OAAO;AAChC;AAYO,SAAS,4BACf,SACA,WACA,UACS;AACT,QAAM,eAAe,OAAO,YAAY,OAAO;AAC/C,QAAM,iBAAiB,OAAO,SAAS,SAAS;AAChD,QAAM,MAAM,aAAa,cAAc,cAAc;AACrD,SAAO,2BAA2B,KAAK,QAAQ;AAChD;AASO,MAAM,6BAA6B,OACzC,QACA,wBACI;AACJ,MAAI,8BAA8B,MAAM,OAAO,UAAU;AAAA,IACxD,IAAI;AAAA,IACJ,SAAS,EAAE,aAAa,KAAK;AAAA,EAC9B,CAAC;AAED,SAAO,4BAA4B,MAAM,SAAS,aAAa,eAC3D,4BAA4B,MAAM,SAAS,SAQ5C;AACJ;AASO,MAAM,uBAAuB,OACnC,QACA,2BACI;AACJ,MAAI,+BAA+B,MAAM,OAAO,UAAU;AAAA,IACzD,IAAI;AAAA,IACJ,SAAS,EAAE,aAAa,KAAK;AAAA,EAC9B,CAAC;AAED,SAAO,6BAA6B,MAAM,SAAS,aAAa,eAC5D,6BAA6B,MAAM,SAAS,SAQ7C;AACJ;AAQO,SAAS,mBAAmB,OAAe;AACjD,MAAI,UAAU,WAAW,KAAK,MAAM,KAAK,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;AAC3E,SAAO,IAAI,OAAO,IAAI,GAAG,CAAC,EAAE,UAAU,SAAS;AAAA,IAC9C,MAAM,QAAQ;AAAA,IACd,SAAS,QAAQ,SAAS;AAAA,IAC1B,cAAc,QAAQ;AAAA,EACvB,CAAC;AACF;AASO,SAAS,mBAAmB,GAAe,GAAwB;AACzE,MAAI,MAAM;AAAG,WAAO;AACpB,MAAI,EAAE,WAAW,EAAE;AAAQ,WAAO;AAClC,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAClC,QAAI,EAAE,CAAC,MAAM,EAAE,CAAC;AAAG,aAAO;AAAA,EAC3B;AACA,SAAO;AACR;AAQO,SAAS,gBAAgB,KAAe;AAC9C,MAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,WAAO,IAAI,IAAI,CAAC,SAAS,gBAAgB,IAAI,CAAC;AAAA,EAC/C,WAAW,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AACnD,WAAO,OAAO;AAAA,MACb,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AACzC,cAAM,SAAS,aAAa,GAAG;AAC/B,eAAO,CAAC,QAAQ,gBAAgB,KAAK,CAAC;AAAA,MACvC,CAAC;AAAA,IACF;AAAA,EACD,OAAO;AACN,WAAO;AAAA,EACR;AACD;AAQA,SAAS,aAAa,KAAqB;AAC1C,SAAO,IAAI,QAAQ,YAAY,CAAC,WAAW,IAAI,OAAO,YAAY,GAAG;AACtE;",
  "names": []
}
