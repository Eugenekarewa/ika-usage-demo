{
  "version": 3,
  "sources": ["../../../src/eth-light-client/eth-light-client.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport {\n\tget_current_period,\n\tget_initial_state_bcs,\n\ttry_verify_proof,\n} from '@dwallet-network/eth-light-client-wasm';\nimport { ethers } from 'ethers';\n\nimport { bcs } from '../bcs/index.js';\nimport { TransactionBlock } from '../builder/index.js';\nimport type { DWalletClient } from '../client/index.js';\nimport type { Keypair } from '../cryptography/index.js';\nimport {\n\tgetBeaconBlockData,\n\tgetBootstrapData,\n\tgetFinalityUpdate,\n\tgetOptimisticUpdate,\n\tgetProof,\n\tgetUpdates,\n} from './rpc.js';\nimport { getEthereumStateById, getLatestEthereumStateById, stringToArrayU8Bcs } from './utils.js';\n\nconst packageId = '0x3';\nconst ethDWalletModuleName = 'eth_dwallet';\nconst ethereumStateModuleName = 'ethereum_state';\n\n/**\n * Connects a dWallet to be controlled by an Ethereum smart contract.\n *\n * This function links a dWallet within the dWallet blockchain environment to an Ethereum smart contract.\n * By creating an Ethereum dWallet capability, it allows the dWallet to interact with Ethereum transactions\n * and be managed through the specified smart contract.\n *\n * **Arguments**\n * @param {string} dwalletCapId - The ObjectID of the dWallet capability.\n * @param {string} latestEthereumStateId - The ObjectID of the latest Ethereum state.\n * @param {Keypair} keypair - The keypair used to sign the transaction.\n * @param {DWalletClient} client - The dWallet client instance.\n */\nexport const createEthereumDWallet = async (\n\tdwalletCapId: string,\n\tlatestEthereumStateId: string,\n\tkeypair: Keypair,\n\tclient: DWalletClient,\n) => {\n\tconst tx = new TransactionBlock();\n\ttx.moveCall({\n\t\ttarget: `${packageId}::${ethDWalletModuleName}::create_eth_dwallet_cap`,\n\t\targuments: [tx.object(dwalletCapId), tx.object(latestEthereumStateId)],\n\t});\n\n\tlet result = await client.signAndExecuteTransactionBlock({\n\t\tsigner: keypair,\n\t\ttransactionBlock: tx,\n\t\toptions: { showEffects: true },\n\t});\n\n\tif (result.effects?.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t'Failed to verify Ethereum state. Transaction effects: ' + JSON.stringify(result.effects),\n\t\t);\n\t}\n\n\treturn result.effects?.created?.at(0)?.reference.objectId;\n};\n\n/**\n * Initializes a shared LatestEthereumState object in the dWallet network with the given checkpoint.\n *\n * This function should only be called once to initialize the Ethereum state. After the state is initialized,\n * the Ethereum state object ID is saved, and the state is updated whenever a new state is successfully verified.\n *\n * **Logic**\n * 1. **Select Checkpoint**: Determines the initial checkpoint based on the specified Ethereum network.\n * 2. **Fetch Bootstrap Data**: Retrieves the bootstrap data required to initialize the Ethereum light client state.\n * 3. **Initialize State**: Uses the bootstrap data to initialize the Ethereum light client state in BCS format.\n * 4. **Fetch Updates**: Retrieves updates from the Ethereum consensus RPC since the initial sync period.\n * 5. **Prepare Transaction**: Constructs a transaction to call the `init_state` function in the Ethereum state module,\n *    providing the necessary arguments such as the state bytes, network, contract address, and updates.\n * 6. **Execute Transaction**: Signs and executes the transaction to initialize the Ethereum state on the dWallet network.\n *\n * **Arguments**\n * @param {string} network - The Ethereum network to initialize (e.g., 'mainnet' or 'holesky').\n * @param {string} rpc - The Ethereum consensus RPC endpoint.\n * @param {string} contractAddress - The address of the Ethereum smart contract.\n * @param {number} contractApprovedTxSlot - The slot of the data structure that holds approved transactions in the Ethereum smart contract.\n * @param {Keypair} keypair - The keypair used to sign the transaction.\n * @param {DWalletClient} client - The dWallet client instance.\n */\nexport const initEthereumState = async (\n\tnetwork: string,\n\trpc: string,\n\tcontractAddress: string,\n\tcontractApprovedTxSlot: number,\n\tkeypair: Keypair,\n\tclient: DWalletClient,\n) => {\n\tlet checkpoint = '';\n\tswitch (network) {\n\t\tcase 'mainnet': {\n\t\t\tcheckpoint = '0x886083d6ba589617fabc0e69127982299f60426ddbf863ade18b3dd30259c11d';\n\t\t\tbreak;\n\t\t}\n\t\tcase 'holesky': {\n\t\t\tcheckpoint = '0x089ad025c4a629091ea8ff20ba34f3eaf5b2c690f1a9e2c29a64022d95ddf1a4';\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new Error('Invalid network');\n\t\t}\n\t}\n\tlet bootstrapJson = await getBootstrapData(rpc, checkpoint);\n\tlet bootstrap = bootstrapJson['data'];\n\n\tlet state = get_initial_state_bcs(checkpoint, rpc, network, bootstrap);\n\tlet stateBytes: Uint8Array = state['bytes'];\n\tlet syncPeriod = get_current_period(stateBytes);\n\n\tlet updatesResponseJson = await getUpdates(rpc, syncPeriod);\n\tlet updatesJson = JSON.stringify(updatesResponseJson.map((update: any) => update['data']));\n\tlet updatesBcs = stringToArrayU8Bcs(updatesJson);\n\n\tlet finalityUpdateResponse = await getFinalityUpdate(rpc);\n\tlet finalityUpdateJson = JSON.stringify(finalityUpdateResponse['data']);\n\tlet finalityUpdateBcs = stringToArrayU8Bcs(finalityUpdateJson);\n\n\tlet optimisticUpdateResponse = await getOptimisticUpdate(rpc);\n\tlet optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse['data']);\n\tlet optimisticUpdateBcs = stringToArrayU8Bcs(optimisticUpdateJson);\n\n\tlet stateBcs = bcs.vector(bcs.u8()).serialize(stateBytes, {\n\t\tsize: stateBytes.length,\n\t\tmaxSize: stateBytes.length * 2,\n\t\tallocateSize: stateBytes.length,\n\t});\n\n\t// Get Beacon block data for the latest finalized block.\n\tlet beaconBlockData = await getBeaconBlockData(rpc, finalityUpdateResponse);\n\tlet beaconBlockTypeBcs = stringToArrayU8Bcs(beaconBlockData.blockType);\n\tlet beaconBlockBcs = stringToArrayU8Bcs(beaconBlockData.blockJsonString);\n\tlet beaconBlockBodyBcs = stringToArrayU8Bcs(beaconBlockData.blockBodyJsonString);\n\tlet beaconBlockExecutionPayloadBcs = stringToArrayU8Bcs(\n\t\tbeaconBlockData.blockExecutionPayloadJsonString,\n\t);\n\n\tlet contractAddressArrayU8 = ethers.getBytes(contractAddress);\n\tlet contractAddressBcs = bcs.vector(bcs.u8()).serialize(contractAddressArrayU8);\n\n\tconst tx = new TransactionBlock();\n\ttx.moveCall({\n\t\ttarget: `${packageId}::${ethereumStateModuleName}::init_state`,\n\t\targuments: [\n\t\t\ttx.pure(stateBcs),\n\t\t\ttx.pure(network),\n\t\t\ttx.pure(contractAddressBcs),\n\t\t\ttx.pure.u64(contractApprovedTxSlot),\n\t\t\ttx.pure(updatesBcs),\n\t\t\ttx.pure(finalityUpdateBcs),\n\t\t\ttx.pure(optimisticUpdateBcs),\n\t\t\ttx.pure(beaconBlockBcs),\n\t\t\ttx.pure(beaconBlockBodyBcs),\n\t\t\ttx.pure(beaconBlockExecutionPayloadBcs),\n\t\t\ttx.pure(beaconBlockTypeBcs),\n\t\t],\n\t\ttypeArguments: [],\n\t});\n\n\tlet result = await client.signAndExecuteTransactionBlock({\n\t\tsigner: keypair,\n\t\ttransactionBlock: tx,\n\t\toptions: { showEffects: true },\n\t});\n\n\treturn result.effects?.created?.filter(\n\t\t(o) =>\n\t\t\ttypeof o.owner === 'object' &&\n\t\t\t'Shared' in o.owner &&\n\t\t\to.owner.Shared.initial_shared_version !== undefined,\n\t)[0].reference!.objectId!;\n};\n\n/**\n * Approves an Ethereum transaction for a given dWallet.\n *\n * Interacts with the Ethereum light client to verify and approve a transaction message\n * using an Ethereum smart contract linked to a dWallet within the dWallet blockchain context.\n * The verification of the state and message is done offline, inside the dWallet module.\n *\n * **Logic**\n * 1. **Retrieve Configuration**: Starts by retrieving the latest Ethereum state object.\n * 2. **Fetch Ethereum Objects**: Retrieves and deserializes the latest Ethereum state and the current Ethereum state data to collect the latest Ethereum state data.\n * 3. **Initialize Light Client**: Initializes the Ethereum light client with the deserialized Ethereum state.\n * 4. **Prepare Proof Parameters**: Constructs proof request parameters using the message, dWallet ID, and data slot from the latest Ethereum state object.\n * 5. **Fetch Updates and Proofs**: Retrieves the necessary updates and cryptographic proofs from the Ethereum light client.\n * 6. **Build Transaction**: Uses the transaction builder to serialize transaction parameters, including the Ethereum state, updates, and shared state object, and prepares the transaction to call the `verify_new_state` function in the Ethereum state module.\n * 7. **Send Transaction**: Constructs the transaction data, including the proof and dWallet ID, and executes it.\n *\n * **Arguments**\n * @param {string} ethDwalletCapId - The ObjectID of the Ethereum dWallet capability, representing the link between the dWallet and Ethereum.\n * @param {string} message - The Ethereum transaction message to be approved.\n * @param {string} dWalletID - The ObjectID of the dWallet to which the transaction belongs.\n * @param {string} latestStateObjectID - The ObjectID of the latest Ethereum state.\n * @param {string} executionRpc - The Ethereum execution RPC endpoint.\n * @param {string} consensusRpc - The Ethereum consensus RPC endpoint.\n * @param {Keypair} keypair - The keypair used to sign the transaction.\n * @param {DWalletClient} client - The dWallet client instance.\n */\nexport const approveEthereumMessage = async (\n\tethDwalletCapId: string,\n\tmessage: string,\n\tdWalletID: string,\n\tlatestStateObjectID: string,\n\texecutionRpc: string,\n\tconsensusRpc: string,\n\tkeypair: Keypair,\n\tclient: DWalletClient,\n) => {\n\tlet latestEthereumStateObj = await getLatestEthereumStateById(client, latestStateObjectID);\n\tlet currentEthereumStateID = latestEthereumStateObj?.eth_state_id as string;\n\tlet currentEthereumStateObj = await getEthereumStateById(client, currentEthereumStateID);\n\tlet currentEthereumStateData = currentEthereumStateObj?.data as number[];\n\tlet currentEthereumStateArrayU8 = Uint8Array.from(currentEthereumStateData);\n\n\tlet dataSlot = latestEthereumStateObj?.eth_smart_contract_slot as number;\n\tlet contractAddress = latestEthereumStateObj?.eth_smart_contract_address as number[];\n\tlet contractAddressArrayU8 = Uint8Array.from(contractAddress);\n\tlet contractAddressString = ethers.hexlify(contractAddressArrayU8);\n\n\t// Get the proof for the (message + dWalletID).\n\tlet proof = await getProof(\n\t\tmessage,\n\t\tdWalletID,\n\t\tdataSlot,\n\t\tcontractAddressString,\n\t\tcurrentEthereumStateObj?.block_number as number,\n\t\texecutionRpc,\n\t);\n\tlet state_root = currentEthereumStateObj?.state_root as number[];\n\n\tlet successful_proof = try_verify_proof(\n\t\tproof,\n\t\tcontractAddressString,\n\t\tmessage,\n\t\tethers.getBytes(dWalletID),\n\t\tdataSlot,\n\t\tstate_root,\n\t);\n\n\t// If the proof has failed, then we need to update the state and try again.\n\tif (!successful_proof) {\n\t\tlet syncPeriod = get_current_period(currentEthereumStateArrayU8);\n\n\t\tlet updatesResponseJson = await getUpdates(consensusRpc, syncPeriod);\n\t\tlet updatesJson = JSON.stringify(updatesResponseJson.map((update: any) => update['data']));\n\t\tlet updatesBcs = stringToArrayU8Bcs(updatesJson);\n\n\t\tlet finalityUpdateResponseJson = await getFinalityUpdate(consensusRpc);\n\t\tlet finalityUpdateJson = JSON.stringify(finalityUpdateResponseJson['data']);\n\t\tlet finalityUpdateBcs = stringToArrayU8Bcs(finalityUpdateJson);\n\n\t\tlet optimisticUpdateResponse = await getOptimisticUpdate(consensusRpc);\n\t\tlet optimisticUpdateJson = JSON.stringify(optimisticUpdateResponse['data']);\n\t\tlet optimisticUpdateBcs = stringToArrayU8Bcs(optimisticUpdateJson);\n\n\t\tlet beaconBlockData = await getBeaconBlockData(consensusRpc, finalityUpdateResponseJson);\n\t\tlet beaconBlockTypeBcs = stringToArrayU8Bcs(beaconBlockData.blockType);\n\t\tlet beaconBlockBcs = stringToArrayU8Bcs(beaconBlockData.blockJsonString);\n\t\tlet beaconBlockBodyBcs = stringToArrayU8Bcs(beaconBlockData.blockBodyJsonString);\n\t\tlet beaconBlockExecutionPayloadBcs = stringToArrayU8Bcs(\n\t\t\tbeaconBlockData.blockExecutionPayloadJsonString,\n\t\t);\n\n\t\tconst tx = new TransactionBlock();\n\t\ttx.moveCall({\n\t\t\ttarget: `${packageId}::${ethereumStateModuleName}::verify_new_state`,\n\t\t\targuments: [\n\t\t\t\ttx.pure(updatesBcs),\n\t\t\t\ttx.pure(finalityUpdateBcs),\n\t\t\t\ttx.pure(optimisticUpdateBcs),\n\t\t\t\ttx.object(latestStateObjectID),\n\t\t\t\ttx.object(currentEthereumStateID),\n\t\t\t\ttx.pure(beaconBlockBcs),\n\t\t\t\ttx.pure(beaconBlockBodyBcs),\n\t\t\t\ttx.pure(beaconBlockExecutionPayloadBcs),\n\t\t\t\ttx.pure(beaconBlockTypeBcs),\n\t\t\t],\n\t\t});\n\n\t\tlet txResult = await client.signAndExecuteTransactionBlock({\n\t\t\tsigner: keypair,\n\t\t\ttransactionBlock: tx,\n\t\t\toptions: { showEffects: true },\n\t\t});\n\n\t\tif (txResult.effects?.status.status !== 'success') {\n\t\t\tthrow new Error(\n\t\t\t\t'Failed to verify Ethereum state. Transaction effects: ' + JSON.stringify(txResult.effects),\n\t\t\t);\n\t\t}\n\n\t\t// Get the latest Ethereum state again, to get the updated state after it is verified.\n\t\tlatestEthereumStateObj = await getLatestEthereumStateById(client, latestStateObjectID);\n\t\tcurrentEthereumStateID = latestEthereumStateObj?.eth_state_id as string;\n\t\tcurrentEthereumStateObj = await getEthereumStateById(client, currentEthereumStateID);\n\n\t\t// Get the proof again, using the updated state.\n\t\tproof = await getProof(\n\t\t\tmessage,\n\t\t\tdWalletID,\n\t\t\tdataSlot,\n\t\t\tcontractAddressString,\n\t\t\tcurrentEthereumStateObj?.block_number as number,\n\t\t\texecutionRpc,\n\t\t);\n\t}\n\n\t// Retry the verification with the updated state. If it fails again, an error will be returned.\n\tsuccessful_proof = try_verify_proof(\n\t\tproof,\n\t\tcontractAddressString,\n\t\tmessage,\n\t\tethers.getBytes(dWalletID),\n\t\tdataSlot,\n\t\tstate_root,\n\t);\n\n\tif (!successful_proof) {\n\t\tthrow new Error('Failed to verify Ethereum state');\n\t}\n\n\tlet proofBcs = stringToArrayU8Bcs(JSON.stringify(proof));\n\tlet messageBcs = stringToArrayU8Bcs(message);\n\n\tconst tx2 = new TransactionBlock();\n\ttx2.moveCall({\n\t\ttarget: `${packageId}::${ethDWalletModuleName}::approve_message`,\n\t\targuments: [\n\t\t\ttx2.object(ethDwalletCapId),\n\t\t\ttx2.pure(messageBcs),\n\t\t\ttx2.object(dWalletID),\n\t\t\ttx2.object(latestStateObjectID),\n\t\t\ttx2.object(currentEthereumStateID),\n\t\t\ttx2.pure(proofBcs),\n\t\t],\n\t});\n\n\tlet res = await client.devInspectTransactionBlock({\n\t\tsender: keypair.toSuiAddress(),\n\t\ttransactionBlock: tx2,\n\t});\n\n\tconst messageApprovalBcs = new Uint8Array(\n\t\tres.results?.at(0)?.returnValues?.at(0)?.at(0)! as number[],\n\t);\n\n\tlet txResult = await client.signAndExecuteTransactionBlock({\n\t\tsigner: keypair,\n\t\ttransactionBlock: tx2,\n\t\toptions: { showEffects: true },\n\t});\n\n\tif (txResult.effects?.status.status !== 'success') {\n\t\tthrow new Error('Failed to verify Ethereum state');\n\t}\n\treturn messageApprovalBcs;\n};\n"],
  "mappings": "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",
  "names": ["txResult"]
}
