import { FINALIZED_ROOT_DEPTH_ELECTRA } from "@lodestar/params";
export function isExecutionPayload(payload) {
    // we just check transactionsRoot for determining as it the base field
    // that is present and differs from ExecutionPayload for all forks
    return payload.transactions !== undefined;
}
export function isExecutionPayloadHeader(payload) {
    // we just check transactionsRoot for determining as it the base field
    // that is present and differs from ExecutionPayload for all forks
    return payload.transactionsRoot !== undefined;
}
export function isExecutionPayloadAndBlobsBundle(data) {
    return data.blobsBundle !== undefined;
}
export function isBlindedBeaconBlock(block) {
    return block.body !== null && isBlindedBeaconBlockBody(block.body);
}
export function isBlindedSignedBeaconBlock(signedBlock) {
    return signedBlock.message.body.executionPayloadHeader !== undefined;
}
export function isBlindedBeaconBlockBody(body) {
    return body.executionPayloadHeader !== undefined;
}
export function isBlockContents(data) {
    return data.kzgProofs !== undefined;
}
export function isSignedBlockContents(data) {
    return data.kzgProofs !== undefined;
}
export function isElectraAttestation(attestation) {
    return attestation.committeeBits !== undefined;
}
export function isElectraSingleAttestation(singleAttestation) {
    return singleAttestation.committeeIndex !== undefined;
}
export function isElectraLightClientUpdate(update) {
    const updatePostElectra = update;
    return (updatePostElectra.finalityBranch !== undefined &&
        updatePostElectra.finalityBranch.length === FINALIZED_ROOT_DEPTH_ELECTRA);
}
export function isELectraLightClientFinalityUpdate(update) {
    const updatePostElectra = update;
    return (updatePostElectra.finalityBranch !== undefined &&
        updatePostElectra.finalityBranch.length === FINALIZED_ROOT_DEPTH_ELECTRA);
}
//# sourceMappingURL=typeguards.js.map