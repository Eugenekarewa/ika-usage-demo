import { HashObject } from "@chainsafe/as-sha256";
export declare function hashObjectToUint8Array(obj: HashObject): Uint8Array;
export declare function uint8ArrayToHashObject(byteArr: Uint8Array): HashObject;
type HashIntoFn = (input: Uint8Array, output: Uint8Array) => void;
/** a SHA256 block is 64 bytes */
export declare const BLOCK_SIZE = 64;
/**
 * Merkleize multiple SHA256 blocks in a single Uint8Array into ${output} at ${offset}
 *   - if padFor > 1 blocksBytes need to be multiple of 64 bytes.
 *   - if padFor = 1, blocksBytes need to be at least 32 bytes
 *   - if padFor = 0, throw error
 * blocksBytes is unsafe because it's modified
 */
export declare function doMerkleizeBlocksBytes(blocksBytes: Uint8Array, padFor: number, output: Uint8Array, offset: number, hashInto: HashIntoFn): void;
/**
 * Merkleize multiple SHA256 blocks into ${output} at ${offset}
 * @param blockLimit number of blocks, should be <= blocks.length so that consumer can reuse memory
 * @param padFor is maxChunkCount, should be >= 2
 * @param blocks is unsafe because it's modified
 * @param output the result is stored here
 * @param offset the offset to store the result
 * @param hashInto the hash function of each hasher
 * @param buffer is a temporary buffer of each hasher to work with the hashInto() function
 */
export declare function doMerkleizeBlockArray(blocks: Uint8Array[], blockLimit: number, padFor: number, output: Uint8Array, offset: number, hashInto: HashIntoFn, buffer: Uint8Array): void;
/**
 * Input data is unsafe because it's modified
 * given nLevel = 3
 * digest multiple of 8 chunks = 256 bytes
 * the result is multiple of 1 chunk = 32 bytes
 * this is the same to hashTreeRoot() of multiple validators
 */
export declare function doDigestNLevel(data: Uint8Array, nLevel: number, hashInto: HashIntoFn): Uint8Array;
export {};
