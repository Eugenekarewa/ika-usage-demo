import type { Node } from "./node.ts";
/**
 * HashComputation to be later used to compute hash of nodes from bottom up.
 * This is also an item of a linked list.
 *     ╔═════════════════════╗             ╔══════════════════════╗
 *     ║       dest          ║             ║      next_dest       ║
 *     ║     /      \        ║  ========>  ║     /       \        ║
 *     ║  src0      src1     ║             ║  next_src0  next_src1║
 *     ╚═════════════════════╝             ╚══════════════════════╝
 */
export type HashComputation = {
    src0: Node;
    src1: Node;
    dest: Node;
    next: HashComputation | null;
};
/**
 * Model HashComputation[] at the same level that support reusing the same memory.
 * Before every run, reset() should be called.
 * After every run, clean() should be called.
 */
export declare class HashComputationLevel implements IterableIterator<HashComputation> {
    private _length;
    private _totalLength;
    private head;
    private tail;
    private pointer;
    constructor();
    get length(): number;
    get totalLength(): number;
    /**
     * run before every run
     */
    reset(): void;
    /**
     * Append a new HashComputation to tail.
     * This will overwrite the existing HashComputation if it is not null, or grow the list if needed.
     */
    push(src0: Node, src1: Node, dest: Node): void;
    /**
     * run after every run
     * hashComps may still refer to the old Nodes, we should release them to avoid memory leak.
     */
    clean(): void;
    /**
     * Implement Iterator for this class
     */
    next(): IteratorResult<HashComputation>;
    /**
     * This is convenient method to consume HashComputationLevel with for-of loop
     * See "next" method above for the actual implementation
     */
    [Symbol.iterator](): IterableIterator<HashComputation>;
    /**
     * Not great due to memory allocation, for testing only.
     * This converts all HashComputation with data to an array.
     */
    toArray(): HashComputation[];
    /**
     * For testing only.
     * This dumps all backed HashComputation objects, note that some HashComputation may not have data.
     */
    dump(): HashComputation[];
}
/**
 * Model HashComputationLevel[] at different levels.
 */
export declare class HashComputationGroup {
    readonly byLevel: HashComputationLevel[];
    constructor();
    reset(): void;
    clean(): void;
}
/**
 * Get HashComputations from a root node all the way to the leaf nodes.
 * hcByLevel is the global array to store HashComputationLevel at different levels
 * at this ${node}, we only add more HashComputations starting from ${index}
 *
 * ╔═══ hcByLevel ══════╗
 * ║ level 0            ║
 * ║ level 1            ║
 * ║ ...                ║
 * ║                    ║          node
 * ║                    ║       /        \
 * ║ level ${index}     ║      01        02
 * ║                    ║    /    \    /    \
 * ║ level ${index + 1} ║  03      04 05     06
 * ║                    ║
 * ║ ...                ║
 * ╚════════════════════╝
 */
export declare function getHashComputations(node: Node, index: number, hcByLevel: HashComputationLevel[]): void;
/**
 * Utility to get HashComputationLevel at a specific index.
 */
export declare function levelAtIndex(hcByLevel: HashComputationLevel[], index: number): HashComputationLevel;
