import { LeafNode } from "@chainsafe/persistent-merkle-tree";
import { namedClass } from "../util/named.js";
import { BasicType } from "./basic.js";
/**
 * Boolean: True or False
 * - Notation: `boolean`
 */
export class BooleanType extends BasicType {
    typeName;
    byteLength = 1;
    itemsPerChunk = 32;
    fixedSize = 1;
    minSize = 1;
    maxSize = 1;
    constructor(opts) {
        super();
        this.typeName = opts?.typeName ?? "boolean";
    }
    static named(opts) {
        return new (namedClass(BooleanType, opts.typeName))(opts);
    }
    defaultValue() {
        return false;
    }
    // Serialization + deserialization
    value_serializeToBytes(output, offset, value) {
        output.uint8Array[offset] = value ? 1 : 0;
        return offset + 1;
    }
    value_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        switch (data.uint8Array[start]) {
            case 1:
                return true;
            case 0:
                return false;
            default:
                throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);
        }
    }
    tree_serializeToBytes(output, offset, node) {
        // TODO: Assumes LeafNode has 4 byte uints are primary unit
        output.uint8Array[offset] = node.getUint(4, 0);
        return offset + 1;
    }
    tree_deserializeFromBytes(data, start, end) {
        this.assertValidSize(end - start);
        const value = data.uint8Array[start];
        if (value > 1) {
            throw Error(`Boolean: invalid value ${value}`);
        }
        return LeafNode.fromUint32(value);
    }
    // Fast tree opts
    tree_getFromNode(leafNode) {
        return leafNode.getUint(4, 0) === 1;
    }
    tree_setToNode(leafNode, value) {
        leafNode.setUint(4, 0, value ? 1 : 0);
    }
    tree_getFromPackedNode(leafNode, index) {
        const offsetBytes = index % this.itemsPerChunk;
        return leafNode.getUint(1, offsetBytes) !== 0;
    }
    tree_setToPackedNode(leafNode, index, value) {
        const offsetBytes = index % this.itemsPerChunk;
        leafNode.setUint(1, offsetBytes, value ? 1 : 0);
    }
    // JSON
    fromJson(json) {
        if (typeof json !== "boolean") {
            throw Error(`JSON invalid type ${typeof json} expected boolean`);
        }
        return json;
    }
    toJson(value) {
        return value;
    }
}
//# sourceMappingURL=boolean.js.map